<!Doctype html>
<html id="docs">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link href='https://fonts.googleapis.com/css?family=Roboto:400,100,100italic,300,300italic,400italic,500,500italic,700,700italic,900,900italic' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" href="/css/styles.css"/>
	<script src="/js/script.js"></script>
    <script src="/js/jquery-2.2.0.min.js"></script>
    <script src="/js/non-mini.js"></script>
    <title>Kubernetes - Services in Kubernetes</title>
</head>
<body>
<div id="cellophane" onclick="kub.toggleMenu()"></div>
<header>
	<a href="/" class="logo"></a>
	<div class="nav-buttons" data-auto-burger="primary">
		<a href="/docs" class="button" id="viewDocs">View Documentation</a>
		<a href="/get-started" class="button" id="tryKubernetes">Try Kubernetes</a>
		<button id="hamburger" onclick="kub.toggleMenu()" data-auto-burger-exclude><div></div></button>
	</div>

	<nav id="mainNav">
		<main data-auto-burger="primary">
			<div class="nav-box">
				<h3><a href="">Get Started</a></h3>
				<p>Built for a multi-cloud world, public, private or hybrid. Seamlessly roll out new features.</p>
			</div>
			<div class="nav-box">
				<h3><a href="">Documentation</a></h3>
				<p>Pellentesque in ipsum id orci porta dapibus. Nulla porttitor accumsan tincidunt. </p>
			</div>
			<div class="nav-box">
				<h3><a href="">Community</a></h3>
				<p>Vestibulum ac diam sit amet quam vehicula elementum sed sit amet dui. </p>
			</div>
			<div class="nav-box">
				<h3><a href="">Blog</a></h3>
				<p>Curabitur arcu erat, accumsan id imperdiet et, porttitor at sem. Quisque velit nisi, pretium ut lacinia in. </p>
			</div>
		</main>
		<main data-auto-burger="primary">
			<div class="left">
				<h5 class="github-invite">Interested in hacking on the core Kubernetes code base?</h5>
				<a href="" class="button">View On Github</a>
			</div>

			<div class="right">
				<h5 class="github-invite">Explore the community</h5>
				<div class="social">
					<a href="https://twitter.com/kubernetesio" class="Twitter"><span>twitter</span></a>
					<a href="https://github.com/kubernetes/kubernetes" class="github"><span>Github</span></a>
					<a href="http://slack.k8s.io/" class="slack"><span>Slack</span></a>
					<a href="http://stackoverflow.com/questions/tagged/kubernetes" class="stack-overflow"><span>stackoverflow</span></a>
					<a href="https://groups.google.com/forum/#!forum/google-containers" class="mailing-list"><span>Mailing List</span></a>
				</div>
			</div>
			<div class="clear" style="clear: both"></div>
		</main>
	</nav>
</header>

<!--  HERO  -->
<section id="hero" class="light-text">
	<h1></h1>
	<h5></h5>
	<div id="vendorStrip" class="light-text">
		<ul>
			<li><a href="/v1.1/guides">GUIDES</a></li>
			<li><a href="/v1.1/reference">REFERENCE</a></li>
			<li><a href="/v1.1/samples">SAMPLES</a></li>
			<li><a href="/v1.1/support">SUPPORT</a></li>
		</ul>
		<div class="dropdown">
			<div class="readout"></div>
			<a href="/v1.1">Version 1.1</a>
			<a href="/v1.0">Version 1.0</a>
		</div>
		<input type="text" id="search" placeholder="Search the docs">
	</div>
</section>

<section id="encyclopedia">
	<div id="docsToc">
        <div class="pi-accordion">
            
            

        </div> <!-- /pi-accordion -->
	</div> <!-- /docsToc -->
	<div id="docsContent">
    	<h1>Services in Kubernetes</h1>
		<!-- BEGIN MUNGE: UNVERSIONED_WARNING -->

<!-- END MUNGE: UNVERSIONED_WARNING -->

<h1 id="services-in-kubernetes">Services in Kubernetes</h1>

<p><strong>Table of Contents</strong>
<!-- BEGIN MUNGE: GENERATED_TOC --></p>

<ul>
  <li><a href="#services-in-kubernetes">Services in Kubernetes</a>
    <ul>
      <li><a href="#overview">Overview</a></li>
      <li><a href="#defining-a-service">Defining a service</a>
        <ul>
          <li><a href="#services-without-selectors">Services without selectors</a></li>
        </ul>
      </li>
      <li><a href="#virtual-ips-and-service-proxies">Virtual IPs and service proxies</a></li>
      <li><a href="#multi-port-services">Multi-Port Services</a></li>
      <li><a href="#choosing-your-own-ip-address">Choosing your own IP address</a>
        <ul>
          <li><a href="#why-not-use-round-robin-dns">Why not use round-robin DNS?</a></li>
        </ul>
      </li>
      <li><a href="#discovering-services">Discovering services</a>
        <ul>
          <li><a href="#environment-variables">Environment variables</a></li>
          <li><a href="#dns">DNS</a></li>
        </ul>
      </li>
      <li><a href="#headless-services">Headless services</a></li>
      <li><a href="#publishing-services---service-types">Publishing services - service types</a>
        <ul>
          <li><a href="#type-nodeport">Type NodePort</a></li>
          <li><a href="#type-loadbalancer">Type LoadBalancer</a></li>
          <li><a href="#external-ips">External IPs</a></li>
        </ul>
      </li>
      <li><a href="#shortcomings">Shortcomings</a></li>
      <li><a href="#future-work">Future work</a></li>
      <li><a href="#the-gory-details-of-virtual-ips">The gory details of virtual IPs</a>
        <ul>
          <li><a href="#avoiding-collisions">Avoiding collisions</a></li>
          <li><a href="#ips-and-vips">IPs and VIPs</a></li>
        </ul>
      </li>
      <li><a href="#api-object">API Object</a></li>
    </ul>
  </li>
</ul>

<!-- END MUNGE: GENERATED_TOC -->

<h2 id="overview">Overview</h2>

<p>Kubernetes <a href="pods.html"><code>Pods</code></a> are mortal. They are born and they die, and they
are not resurrected.  <a href="replication-controller.html"><code>ReplicationControllers</code></a> in
particular create and destroy <code>Pods</code> dynamically (e.g. when scaling up or down
or when doing <a href="kubectl/kubectl_rolling-update.html">rolling updates</a>).  While each <code>Pod</code> gets its own IP address, even
those IP addresses cannot be relied upon to be stable over time. This leads to
a problem: if some set of <code>Pods</code> (let’s call them backends) provides
functionality to other <code>Pods</code> (let’s call them frontends) inside the Kubernetes
cluster, how do those frontends find out and keep track of which backends are
in that set?</p>

<p>Enter <code>Services</code>.</p>

<p>A Kubernetes <code>Service</code> is an abstraction which defines a logical set of <code>Pods</code>
and a policy by which to access them - sometimes called a micro-service.  The
set of <code>Pods</code> targeted by a <code>Service</code> is (usually) determined by a <a href="labels.html#label-selectors"><code>Label
Selector</code></a> (see below for why you might want a
<code>Service</code> without a selector).</p>

<p>As an example, consider an image-processing backend which is running with 3
replicas.  Those replicas are fungible - frontends do not care which backend
they use.  While the actual <code>Pods</code> that compose the backend set may change, the
frontend clients should not need to be aware of that or keep track of the list
of backends themselves.  The <code>Service</code> abstraction enables this decoupling.</p>

<p>For Kubernetes-native applications, Kubernetes offers a simple <code>Endpoints</code> API
that is updated whenever the set of <code>Pods</code> in a <code>Service</code> changes.  For
non-native applications, Kubernetes offers a virtual-IP-based bridge to Services
which redirects to the backend <code>Pods</code>.</p>

<h2 id="defining-a-service">Defining a service</h2>

<p>A <code>Service</code> in Kubernetes is a REST object, similar to a <code>Pod</code>.  Like all of the
REST objects, a <code>Service</code> definition can be POSTed to the apiserver to create a
new instance.  For example, suppose you have a set of <code>Pods</code> that each expose
port 9376 and carry a label <code>"app=MyApp"</code>.</p>

<div class="highlight">
  <pre><code class="language-json">{
    "kind": "Service",
    "apiVersion": "v1",
    "metadata": {
        "name": "my-service"
    },
    "spec": {
        "selector": {
            "app": "MyApp"
        },
        "ports": [
            {
                "protocol": "TCP",
                "port": 80,
                "targetPort": 9376
            }
        ]
    }
}
</code></pre>
</div>

<p>This specification will create a new <code>Service</code> object named “my-service” which
targets TCP port 9376 on any <code>Pod</code> with the <code>"app=MyApp"</code> label.  This <code>Service</code>
will also be assigned an IP address (sometimes called the “cluster IP”), which
is used by the service proxies (see below).  The <code>Service</code>’s selector will be
evaluated continuously and the results will be POSTed to an <code>Endpoints</code> object
also named “my-service”.</p>

<p>Note that a <code>Service</code> can map an incoming port to any <code>targetPort</code>.  By default
the <code>targetPort</code> will be set to the same value as the <code>port</code> field.  Perhaps
more interesting is that <code>targetPort</code> can be a string, referring to the name of
a port in the backend <code>Pods</code>.  The actual port number assigned to that name can
be different in each backend <code>Pod</code>. This offers a lot of flexibility for
deploying and evolving your <code>Services</code>.  For example, you can change the port
number that pods expose in the next version of your backend software, without
breaking clients.</p>

<p>Kubernetes <code>Services</code> support <code>TCP</code> and <code>UDP</code> for protocols.  The default
is <code>TCP</code>.</p>

<h3 id="services-without-selectors">Services without selectors</h3>

<p>Services generally abstract access to Kubernetes <code>Pods</code>, but they can also
abstract other kinds of backends.  For example:</p>

<ul>
  <li>You want to have an external database cluster in production, but in test
you use your own databases.</li>
  <li>You want to point your service to a service in another
<a href="namespaces.html"><code>Namespace</code></a> or on another cluster.</li>
  <li>You are migrating your workload to Kubernetes and some of your backends run
outside of Kubernetes.</li>
</ul>

<p>In any of these scenarios you can define a service without a selector:</p>

<div class="highlight">
  <pre><code class="language-json">{
    "kind": "Service",
    "apiVersion": "v1",
    "metadata": {
        "name": "my-service"
    },
    "spec": {
        "ports": [
            {
                "protocol": "TCP",
                "port": 80,
                "targetPort": 9376
            }
        ]
    }
}
</code></pre>
</div>

<p>Because this has no selector, the corresponding <code>Endpoints</code> object will not be
created. You can manually map the service to your own specific endpoints:</p>

<div class="highlight">
  <pre><code class="language-json">{
    "kind": "Endpoints",
    "apiVersion": "v1",
    "metadata": {
        "name": "my-service"
    },
    "subsets": [
        {
            "addresses": [
                { "IP": "1.2.3.4" }
            ],
            "ports": [
                { "port": 80 }
            ]
        }
    ]
}
</code></pre>
</div>

<p>NOTE: Endpoint IPs may not be loopback (127.0.0.0/8), link-local
(169.254.0.0/16), or link-local multicast ((224.0.0.0/24).</p>

<p>Accessing a <code>Service</code> without a selector works the same as if it had selector.
The traffic will be routed to endpoints defined by the user (<code>1.2.3.4:80</code> in
this example).</p>

<h2 id="virtual-ips-and-service-proxies">Virtual IPs and service proxies</h2>

<p>Every node in a Kubernetes cluster runs a <code>kube-proxy</code>.  This application
watches the Kubernetes master for the addition and removal of <code>Service</code>
and <code>Endpoints</code> objects. For each <code>Service</code> it opens a port (randomly chosen)
on the local node.  Any connections made to that port will be proxied to one of
the corresponding backend <code>Pods</code>.  Which backend to use is decided based on the
<code>SessionAffinity</code> of the <code>Service</code>.  Lastly, it installs iptables rules which
capture traffic to the <code>Service</code>’s cluster IP (which is virtual) and <code>Port</code> and
redirects that traffic to the previously described port.</p>

<p>The net result is that any traffic bound for the <code>Service</code> is proxied to an
appropriate backend without the clients knowing anything about Kubernetes or
<code>Services</code> or <code>Pods</code>.</p>

<p><img src="services-overview.png" alt="Services overview diagram" /></p>

<p>By default, the choice of backend is round robin.  Client-IP based session affinity
can be selected by setting <code>service.spec.sessionAffinity</code> to <code>"ClientIP"</code> (the
default is <code>"None"</code>).</p>

<p>As of Kubernetes 1.0, <code>Services</code> are a “layer 3” (TCP/UDP over IP) construct.  We do not
yet have a concept of “layer 7” (HTTP) services.</p>

<h2 id="multi-port-services">Multi-Port Services</h2>

<p>Many <code>Services</code> need to expose more than one port.  For this case, Kubernetes
supports multiple port definitions on a <code>Service</code> object.  When using multiple
ports you must give all of your ports names, so that endpoints can be
disambiguated.  For example:</p>

<div class="highlight">
  <pre><code class="language-json">{
    "kind": "Service",
    "apiVersion": "v1",
    "metadata": {
        "name": "my-service"
    },
    "spec": {
        "selector": {
            "app": "MyApp"
        },
        "ports": [
            {
                "name": "http",
                "protocol": "TCP",
                "port": 80,
                "targetPort": 9376
            },
            {
                "name": "https",
                "protocol": "TCP",
                "port": 443,
                "targetPort": 9377
            }
        ]
    }
}
</code></pre>
</div>

<h2 id="choosing-your-own-ip-address">Choosing your own IP address</h2>

<p>You can specify your own cluster IP address as part of a <code>Service</code> creation
request.  To do this, set the <code>spec.clusterIP</code> field. For example, if you
already have an existing DNS entry that you wish to replace, or legacy systems
that are configured for a specific IP address and difficult to re-configure.
The IP address that a user chooses must be a valid IP address and within the
<code>service-cluster-ip-range</code> CIDR range that is specified by flag to the API
server.  If the IP address value is invalid, the apiserver returns a 422 HTTP
status code to indicate that the value is invalid.</p>

<h3 id="why-not-use-round-robin-dns">Why not use round-robin DNS?</h3>

<p>A question that pops up every now and then is why we do all this stuff with
virtual IPs rather than just use standard round-robin DNS.  There are a few
reasons:</p>

<ul>
  <li>There is a long history of DNS libraries not respecting DNS TTLs and
caching the results of name lookups.</li>
  <li>Many apps do DNS lookups once and cache the results.</li>
  <li>Even if apps and libraries did proper re-resolution, the load of every
client re-resolving DNS over and over would be difficult to manage.</li>
</ul>

<p>We try to discourage users from doing things that hurt themselves.  That said,
if enough people ask for this, we may implement it as an alternative.</p>

<h2 id="discovering-services">Discovering services</h2>

<p>Kubernetes supports 2 primary modes of finding a <code>Service</code> - environment
variables and DNS.</p>

<h3 id="environment-variables">Environment variables</h3>

<p>When a <code>Pod</code> is run on a <code>Node</code>, the kubelet adds a set of environment variables
for each active <code>Service</code>.  It supports both <a href="https://docs.docker.com/userguide/dockerlinks/">Docker links
compatible</a> variables (see
<a href="http://releases.k8s.io/release-1.1/pkg/kubelet/envvars/envvars.go#L49">makeLinkVariables</a>)
and simpler <code>{SVCNAME}_SERVICE_HOST</code> and <code>{SVCNAME}_SERVICE_PORT</code> variables,
where the Service name is upper-cased and dashes are converted to underscores.</p>

<p>For example, the Service <code>"redis-master"</code> which exposes TCP port 6379 and has been
allocated cluster IP address 10.0.0.11 produces the following environment
variables:</p>

<div class="highlight">
  <pre><code class="language-bash">REDIS_MASTER_SERVICE_HOST=10.0.0.11
REDIS_MASTER_SERVICE_PORT=6379
REDIS_MASTER_PORT=tcp://10.0.0.11:6379
REDIS_MASTER_PORT_6379_TCP=tcp://10.0.0.11:6379
REDIS_MASTER_PORT_6379_TCP_PROTO=tcp
REDIS_MASTER_PORT_6379_TCP_PORT=6379
REDIS_MASTER_PORT_6379_TCP_ADDR=10.0.0.11
</code></pre>
</div>

<p><em>This does imply an ordering requirement</em> - any <code>Service</code> that a <code>Pod</code> wants to
access must be created before the <code>Pod</code> itself, or else the environment
variables will not be populated.  DNS does not have this restriction.</p>

<h3 id="dns">DNS</h3>

<p>An optional (though strongly recommended) <a href="http://releases.k8s.io/release-1.1/cluster/addons/README.md">cluster
add-on</a> is a DNS server.  The
DNS server watches the Kubernetes API for new <code>Services</code> and creates a set of
DNS records for each.  If DNS has been enabled throughout the cluster then all
<code>Pods</code> should be able to do name resolution of <code>Services</code> automatically.</p>

<p>For example, if you have a <code>Service</code> called <code>"my-service"</code> in Kubernetes
<code>Namespace</code> <code>"my-ns"</code> a DNS record for <code>"my-service.my-ns"</code> is created.  <code>Pods</code>
which exist in the <code>"my-ns"</code> <code>Namespace</code> should be able to find it by simply doing
a name lookup for <code>"my-service"</code>.  <code>Pods</code> which exist in other <code>Namespaces</code> must
qualify the name as <code>"my-service.my-ns"</code>.  The result of these name lookups is the
cluster IP.</p>

<p>Kubernetes also supports DNS SRV (service) records for named ports.  If the
<code>"my-service.my-ns"</code> <code>Service</code> has a port named <code>"http"</code> with protocol <code>TCP</code>, you
can do a DNS SRV query for <code>"_http._tcp.my-service.my-ns"</code> to discover the port
number for <code>"http"</code>.</p>

<h2 id="headless-services">Headless services</h2>

<p>Sometimes you don’t need or want load-balancing and a single service IP.  In
this case, you can create “headless” services by specifying <code>"None"</code> for the
cluster IP (<code>spec.clusterIP</code>).</p>

<p>For such <code>Services</code>, a cluster IP is not allocated. DNS is configured to return
multiple A records (addresses) for the <code>Service</code> name, which point directly to
the <code>Pods</code> backing the <code>Service</code>.  Additionally, the kube proxy does not handle
these services and there is no load balancing or proxying done by the platform
for them.  The endpoints controller will still create <code>Endpoints</code> records in
the API.</p>

<p>This option allows developers to reduce coupling to the Kubernetes system, if
they desire, but leaves them freedom to do discovery in their own way.
Applications can still use a self-registration pattern and adapters for other
discovery systems could easily be built upon this API.</p>

<h2 id="publishing-services---service-types">Publishing services - service types</h2>

<p>For some parts of your application (e.g. frontends) you may want to expose a
Service onto an external (outside of your cluster, maybe public internet) IP
address, other services should be visible only from inside of the cluster.</p>

<p>Kubernetes <code>ServiceTypes</code> allow you to specify what kind of service you want.
The default and base type is <code>ClusterIP</code>, which exposes a service to connection
from inside the cluster. <code>NodePort</code> and <code>LoadBalancer</code> are two types that expose
services to external traffic.</p>

<p>Valid values for the <code>ServiceType</code> field are:</p>

<ul>
  <li><code>ClusterIP</code>: use a cluster-internal IP only - this is the default and is
discussed above. Choosing this value means that you want this service to be
reachable only from inside of the cluster.</li>
  <li><code>NodePort</code>: on top of having a cluster-internal IP, expose the service on a
port on each node of the cluster (the same port on each node). You’ll be able
to contact the service on any <code>&lt;NodeIP&gt;:NodePort</code> address.</li>
  <li><code>LoadBalancer</code>: on top of having a cluster-internal IP and exposing service
on a NodePort also, ask the cloud provider for a load balancer
which forwards to the <code>Service</code> exposed as a <code>&lt;NodeIP&gt;:NodePort</code>
for each Node.</li>
</ul>

<p>Note that while <code>NodePort</code>s can be TCP or UDP, <code>LoadBalancer</code>s only support TCP
as of Kubernetes 1.0.</p>

<h3 id="type-nodeport">Type NodePort</h3>

<p>If you set the <code>type</code> field to <code>"NodePort"</code>, the Kubernetes master will
allocate a port from a flag-configured range (default: 30000-32767), and each
Node will proxy that port (the same port number on every Node) into your <code>Service</code>.
That port will be reported in your <code>Service</code>’s <code>spec.ports[*].nodePort</code> field.</p>

<p>If you want a specific port number, you can specify a value in the <code>nodePort</code>
field, and the system will allocate you that port or else the API transaction
will fail (i.e. you need to take care about possible port collisions yourself).
The value you specify must be in the configured range for node ports.</p>

<p>This gives developers the freedom to set up their own load balancers, to
configure cloud environments that are not fully supported by Kubernetes, or
even to just expose one or more nodes’ IPs directly.</p>

<p>Note that this Service will be visible as both <code>&lt;NodeIP&gt;:spec.ports[*].nodePort</code>
and <code>spec.clusterIp:spec.ports[*].port</code>.</p>

<h3 id="type-loadbalancer">Type LoadBalancer</h3>

<p>On cloud providers which support external load balancers, setting the <code>type</code>
field to <code>"LoadBalancer"</code> will provision a load balancer for your <code>Service</code>.
The actual creation of the load balancer happens asynchronously, and
information about the provisioned balancer will be published in the <code>Service</code>’s
<code>status.loadBalancer</code> field.  For example:</p>

<div class="highlight">
  <pre><code class="language-json">{
    "kind": "Service",
    "apiVersion": "v1",
    "metadata": {
        "name": "my-service"
    },
    "spec": {
        "selector": {
            "app": "MyApp"
        },
        "ports": [
            {
                "protocol": "TCP",
                "port": 80,
                "targetPort": 9376,
                "nodePort": 30061
            }
        ],
        "clusterIP": "10.0.171.239",
        "loadBalancerIP": "78.11.24.19",
        "type": "LoadBalancer"
    },
    "status": {
        "loadBalancer": {
            "ingress": [
                {
                    "ip": "146.148.47.155"
                }
            ]
        }
    }
}
</code></pre>
</div>

<p>Traffic from the external load balancer will be directed at the backend <code>Pods</code>,
though exactly how that works depends on the cloud provider. Some cloud providers allow
the <code>loadBalancerIP</code> to be specified. In those cases, the load-balancer will be created
with the user-specified <code>loadBalancerIP</code>. If the <code>loadBalancerIP</code> field is not specified,
an ephemeral IP will be assigned to the loadBalancer. If the <code>loadBalancerIP</code> is specified, but the
cloud provider does not support the feature, the field will be ignored.</p>

<h3 id="external-ips">External IPs</h3>

<p>If there are external IPs that route to one or more cluster nodes, Kubernetes services can be exposed on those
<code>externalIPs</code>. Traffic that ingresses into the cluster with the external IP (as destination IP), on the service port,
will be routed to one of the service endpoints. <code>externalIPs</code> are not managed by Kubernetes and are the responsibility
of the cluster administrator.</p>

<p>In the ServiceSpec, <code>externalIPs</code> can be specified along with any of the <code>ServiceTypes</code>.
In the example below, my-service can be accessed by clients on 80.11.12.10:80 (externalIP:port)</p>

<div class="highlight">
  <pre><code class="language-json">{
    "kind": "Service",
    "apiVersion": "v1",
    "metadata": {
        "name": "my-service"
    },
    "spec": {
        "selector": {
            "app": "MyApp"
        },
        "ports": [
            {
                "name": "http",
                "protocol": "TCP",
                "port": 80,
                "targetPort": 9376
            }
        ],
        "externalIPs" : [
            "80.11.12.10"
        ]
    }
}
</code></pre>
</div>

<h2 id="shortcomings">Shortcomings</h2>

<p>We expect that using iptables and userspace proxies for VIPs will work at
small to medium scale, but may not scale to very large clusters with thousands
of Services.  See <a href="http://issue.k8s.io/1107">the original design proposal for
portals</a> for more
details.</p>

<p>Using the kube-proxy obscures the source-IP of a packet accessing a <code>Service</code>.
This makes some kinds of firewalling impossible.</p>

<p>LoadBalancers only support TCP, not UDP.</p>

<p>The <code>Type</code> field is designed as nested functionality - each level adds to the
previous.  This is not strictly required on all cloud providers (e.g. Google Compute Engine does
not need to allocate a <code>NodePort</code> to make <code>LoadBalancer</code> work, but AWS does)
but the current API requires it.</p>

<h2 id="future-work">Future work</h2>

<p>In the future we envision that the proxy policy can become more nuanced than
simple round robin balancing, for example master-elected or sharded.  We also
envision that some <code>Services</code> will have “real” load balancers, in which case the
VIP will simply transport the packets there.</p>

<p>There’s a
<a href="http://issue.k8s.io/3760">proposal</a> to
eliminate userspace proxying in favor of doing it all in iptables.  This should
perform better and fix the source-IP obfuscation, though is less flexible than
arbitrary userspace code.</p>

<p>We intend to have first-class support for L7 (HTTP) <code>Services</code>.</p>

<p>We intend to have more flexible ingress modes for <code>Services</code> which encompass
the current <code>ClusterIP</code>, <code>NodePort</code>, and <code>LoadBalancer</code> modes and more.</p>

<h2 id="the-gory-details-of-virtual-ips">The gory details of virtual IPs</h2>

<p>The previous information should be sufficient for many people who just want to
use <code>Services</code>.  However, there is a lot going on behind the scenes that may be
worth understanding.</p>

<h3 id="avoiding-collisions">Avoiding collisions</h3>

<p>One of the primary philosophies of Kubernetes is that users should not be
exposed to situations that could cause their actions to fail through no fault
of their own.  In this situation, we are looking at network ports - users
should not have to choose a port number if that choice might collide with
another user.  That is an isolation failure.</p>

<p>In order to allow users to choose a port number for their <code>Services</code>, we must
ensure that no two <code>Services</code> can collide.  We do that by allocating each
<code>Service</code> its own IP address.</p>

<p>To ensure each service receives a unique IP, an internal allocator atomically
updates a global allocation map in etcd prior to each service. The map object
must exist in the registry for services to get IPs, otherwise creations will
fail with a message indicating an IP could not be allocated. A background
controller is responsible for creating that map (to migrate from older versions
of Kubernetes that used in memory locking) as well as checking for invalid
assignments due to administrator intervention and cleaning up any IPs
that were allocated but which no service currently uses.</p>

<h3 id="ips-and-vips">IPs and VIPs</h3>

<p>Unlike <code>Pod</code> IP addresses, which actually route to a fixed destination,
<code>Service</code> IPs are not actually answered by a single host.  Instead, we use
<code>iptables</code> (packet processing logic in Linux) to define virtual IP addresses
which are transparently redirected as needed.  When clients connect to the
VIP, their traffic is automatically transported to an appropriate endpoint.
The environment variables and DNS for <code>Services</code> are actually populated in
terms of the <code>Service</code>’s VIP and port.</p>

<p>As an example, consider the image processing application described above.
When the backend <code>Service</code> is created, the Kubernetes master assigns a virtual
IP address, for example 10.0.0.1.  Assuming the <code>Service</code> port is 1234, the
<code>Service</code> is observed by all of the <code>kube-proxy</code> instances in the cluster.
When a proxy sees a new <code>Service</code>, it opens a new random port, establishes an
iptables redirect from the VIP to this new port, and starts accepting
connections on it.</p>

<p>When a client connects to the VIP the iptables rule kicks in, and redirects
the packets to the <code>Service proxy</code>’s own port.  The <code>Service proxy</code> chooses a
backend, and starts proxying traffic from the client to the backend.</p>

<p>This means that <code>Service</code> owners can choose any port they want without risk of
collision.  Clients can simply connect to an IP and port, without being aware
of which <code>Pods</code> they are actually accessing.</p>

<p><img src="services-detail.png" alt="Services detailed diagram" /></p>

<h2 id="api-object">API Object</h2>

<p>Service is a top-level resource in the kubernetes REST API. More details about the
API object can be found at: <a href="http://kubernetes.io/v1.1/docs/api-reference/v1/definitions.html#_v1_service">Service API
object</a>.</p>

<!-- BEGIN MUNGE: IS_VERSIONED -->
<!-- TAG IS_VERSIONED -->
<!-- END MUNGE: IS_VERSIONED -->

<!-- BEGIN MUNGE: GENERATED_ANALYTICS -->
<p><a href=""><img src="https://kubernetes-site.appspot.com/UA-36037335-10/GitHub/docs/user-guide/services.md?pixel" alt="Analytics" /></a>
<!-- END MUNGE: GENERATED_ANALYTICS --></p>


	</div>
</section>


<footer>
	<main class="light-text">
		<nav>
			<a href="/getting-started.html">Getting Started</a>
			<a href="/docs.html">Documentation</a>
			<a href="http://blog.kubernetes.io/">Blog</a>
			<a href="/foobang.html">Community</a>
		</nav>
		<div class="social">
			<a href="https://twitter.com/kubernetesio" class="twitter"><span>twitter</span></a>
			<a href="https://github.com/kubernetes/kubernetes" class="github"><span>Github</span></a>
			<a href="http://slack.k8s.io/" class="slack"><span>Slack</span></a>
			<a href="http://stackoverflow.com/questions/tagged/kubernetes" class="stack-overflow"><span>stackoverflow</span></a>
			<a href="https://groups.google.com/forum/#!forum/google-containers" class="mailing-list"><span>Mailing List</span></a>
			<label for="wishField">I wish this page <input type="text" id="wishField" name="wishField" placeholder="made better textfield suggestions"></label>
		</div>
		<div class="center">&copy; 2016 Kubernetes</div>
	</main>
</footer>

</body>
</html>



