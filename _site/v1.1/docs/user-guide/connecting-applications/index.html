<!Doctype html>
<html id="docs">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link href='https://fonts.googleapis.com/css?family=Roboto:400,100,100italic,300,300italic,400italic,500,500italic,700,700italic,900,900italic' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" href="/css/styles.css"/>
	<script src="/js/script.js"></script>
    <script src="/js/jquery-2.2.0.min.js"></script>
    <script src="/js/non-mini.js"></script>
    <title>Kubernetes - Kubernetes User Guide: Managing Applications: Connecting applications</title>
</head>
<body>
<div id="cellophane" onclick="kub.toggleMenu()"></div>
<header>
	<a href="/" class="logo"></a>
	<div class="nav-buttons" data-auto-burger="primary">
		<a href="/docs" class="button" id="viewDocs">View Documentation</a>
		<a href="/get-started" class="button" id="tryKubernetes">Try Kubernetes</a>
		<button id="hamburger" onclick="kub.toggleMenu()" data-auto-burger-exclude><div></div></button>
	</div>

	<nav id="mainNav">
		<main data-auto-burger="primary">
			<div class="nav-box">
				<h3><a href="">Get Started</a></h3>
				<p>Built for a multi-cloud world, public, private or hybrid. Seamlessly roll out new features.</p>
			</div>
			<div class="nav-box">
				<h3><a href="">Documentation</a></h3>
				<p>Pellentesque in ipsum id orci porta dapibus. Nulla porttitor accumsan tincidunt. </p>
			</div>
			<div class="nav-box">
				<h3><a href="">Community</a></h3>
				<p>Vestibulum ac diam sit amet quam vehicula elementum sed sit amet dui. </p>
			</div>
			<div class="nav-box">
				<h3><a href="">Blog</a></h3>
				<p>Curabitur arcu erat, accumsan id imperdiet et, porttitor at sem. Quisque velit nisi, pretium ut lacinia in. </p>
			</div>
		</main>
		<main data-auto-burger="primary">
			<div class="left">
				<h5 class="github-invite">Interested in hacking on the core Kubernetes code base?</h5>
				<a href="" class="button">View On Github</a>
			</div>

			<div class="right">
				<h5 class="github-invite">Explore the community</h5>
				<div class="social">
					<a href="https://twitter.com/kubernetesio" class="Twitter"><span>twitter</span></a>
					<a href="https://github.com/kubernetes/kubernetes" class="github"><span>Github</span></a>
					<a href="http://slack.k8s.io/" class="slack"><span>Slack</span></a>
					<a href="http://stackoverflow.com/questions/tagged/kubernetes" class="stack-overflow"><span>stackoverflow</span></a>
					<a href="https://groups.google.com/forum/#!forum/google-containers" class="mailing-list"><span>Mailing List</span></a>
				</div>
			</div>
			<div class="clear" style="clear: both"></div>
		</main>
	</nav>
</header>

<!--  HERO  -->
<section id="hero" class="light-text">
	<h1></h1>
	<h5></h5>
	<div id="vendorStrip" class="light-text">
		<ul>
			<li><a href="/v1.1/">GUIDES</a></li>
			<li><a href="/v1.1/reference">REFERENCE</a></li>
			<li><a href="/v1.1/samples">SAMPLES</a></li>
			<li><a href="/v1.1/support">SUPPORT</a></li>
		</ul>
		<div class="dropdown">
			<div class="readout"></div>
			<a href="/v1.1">Version 1.1</a>
			<a href="/v1.0">Version 1.0</a>
		</div>
		<input type="text" id="search" placeholder="Search the docs">
	</div>
</section>

<section id="encyclopedia">
	<div id="docsToc">
        <div class="pi-accordion">
            
            

        </div> <!-- /pi-accordion -->
	</div> <!-- /docsToc -->
	<div id="docsContent">
    	<h1>Kubernetes User Guide: Managing Applications: Connecting applications</h1>
		<!-- BEGIN MUNGE: UNVERSIONED_WARNING -->

<!-- END MUNGE: UNVERSIONED_WARNING -->

<h1 id="kubernetes-user-guide-managing-applications-connecting-applications">Kubernetes User Guide: Managing Applications: Connecting applications</h1>

<p><strong>Table of Contents</strong>
<!-- BEGIN MUNGE: GENERATED_TOC --></p>

<ul>
  <li><a href="#kubernetes-user-guide-managing-applications-connecting-applications">Kubernetes User Guide: Managing Applications: Connecting applications</a></li>
  <li><a href="#the-kubernetes-model-for-connecting-containers">The Kubernetes model for connecting containers</a>
    <ul>
      <li><a href="#exposing-pods-to-the-cluster">Exposing pods to the cluster</a></li>
      <li><a href="#creating-a-service">Creating a Service</a></li>
      <li><a href="#accessing-the-service">Accessing the Service</a>
        <ul>
          <li><a href="#environment-variables">Environment Variables</a></li>
          <li><a href="#dns">DNS</a></li>
        </ul>
      </li>
      <li><a href="#securing-the-service">Securing the Service</a></li>
      <li><a href="#exposing-the-service">Exposing the Service</a></li>
      <li><a href="#whats-next">What’s next?</a></li>
    </ul>
  </li>
</ul>

<!-- END MUNGE: GENERATED_TOC -->

<h1 id="the-kubernetes-model-for-connecting-containers">The Kubernetes model for connecting containers</h1>

<p>Now that you have a continuously running, replicated application you can expose it on a network. Before discussing the Kubernetes approach to networking, it is worthwhile to contrast it with the “normal” way networking works with Docker.</p>

<p>By default, Docker uses host-private networking, so containers can talk to other containers only if they are on the same machine. In order for Docker containers to communicate across nodes, they must be allocated ports on the machine’s own IP address, which are then forwarded or proxied to the containers. This obviously means that containers must either coordinate which ports they use very carefully or else be allocated ports dynamically.</p>

<p>Coordinating ports across multiple developers is very difficult to do at scale and exposes users to cluster-level issues outside of their control. Kubernetes assumes that pods can communicate with other pods, regardless of which host they land on. We give every pod its own cluster-private-IP address so you do not need to explicitly create links between pods or mapping container ports to host ports. This means that containers within a Pod can all reach each other’s ports on localhost, and all pods in a cluster can see each other without NAT. The rest of this document will elaborate on how you can run reliable services on such a networking model.</p>

<p>This guide uses a simple nginx server to demonstrate proof of concept. The same principles are embodied in a more complete <a href="http://blog.kubernetes.io/2015/07/strong-simple-ssl-for-kubernetes.html">Jenkins CI application</a>.</p>

<h2 id="exposing-pods-to-the-cluster">Exposing pods to the cluster</h2>

<p>We did this in a previous example, but lets do it once again and focus on the networking perspective. Create an nginx pod, and note that it has a container port specification:</p>

<div class="highlight">
  <pre><code class="language-yaml">$ cat nginxrc.yaml
apiVersion: v1
kind: ReplicationController
metadata:
  name: my-nginx
spec:
  replicas: 2
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80
</code></pre>
</div>

<p>This makes it accessible from any node in your cluster. Check the nodes the pod is running on:</p>

<div class="highlight">
  <pre><code class="language-console">$ kubectl create -f ./nginxrc.yaml
$ kubectl get pods -l app=nginx -o wide
my-nginx-6isf4   1/1       Running   0          2h        e2e-test-beeps-minion-93ly
my-nginx-t26zt   1/1       Running   0          2h        e2e-test-beeps-minion-93ly
</code></pre>
</div>

<p>Check your pods’ IPs:</p>

<div class="highlight">
  <pre><code class="language-console">$ kubectl get pods -l app=nginx -o json | grep podIP
                "podIP": "10.245.0.15",
                "podIP": "10.245.0.14",
</code></pre>
</div>

<p>You should be able to ssh into any node in your cluster and curl both IPs. Note that the containers are <em>not</em> using port 80 on the node, nor are there any special NAT rules to route traffic to the pod. This means you can run multiple nginx pods on the same node all using the same containerPort and access them from any other pod or node in your cluster using IP. Like Docker, ports can still be published to the host node’s interface(s), but the need for this is radically diminished because of the networking model.</p>

<p>You can read more about <a href="../admin/networking.html#how-to-achieve-this">how we achieve this</a> if you’re curious.</p>

<h2 id="creating-a-service">Creating a Service</h2>

<p>So we have pods running nginx in a flat, cluster wide, address space. In theory, you could talk to these pods directly, but what happens when a node dies? The pods die with it, and the replication controller will create new ones, with different IPs. This is the problem a Service solves.</p>

<p>A Kubernetes Service is an abstraction which defines a logical set of Pods running somewhere in your cluster, that all provide the same functionality. When created, each Service is assigned a unique IP address (also called clusterIP). This address is tied to the lifespan of the Service, and will not change while the Service is alive. Pods can be configured to talk to the Service, and know that communication to the Service will be automatically load-balanced out to some pod that is a member of the Service.</p>

<p>You can create a Service for your 2 nginx replicas with the following yaml:</p>

<div class="highlight">
  <pre><code class="language-yaml">$ cat nginxsvc.yaml
apiVersion: v1
kind: Service
metadata:
  name: nginxsvc
  labels:
    app: nginx
spec:
  ports:
  - port: 80
    protocol: TCP
  selector:
    app: nginx
</code></pre>
</div>

<p>This specification will create a Service which targets TCP port 80 on any Pod with the <code>app=nginx</code> label, and expose it on an abstracted Service port (<code>targetPort</code>: is the port the container accepts traffic on, <code>port</code>: is the abstracted Service port, which can be any port other pods use to access the Service). View <a href="http://kubernetes.io/v1.1/docs/api-reference/v1/definitions.html#_v1_service">service API object</a> to see the list of supported fields in service definition.
Check your Service:</p>

<div class="highlight">
  <pre><code class="language-console">$ kubectl get svc
NAME         CLUSTER_IP       EXTERNAL_IP       PORT(S)                SELECTOR     AGE
kubernetes   10.179.240.1     &lt;none&gt;            443/TCP                &lt;none&gt;       8d
nginxsvc     10.179.252.126   122.222.183.144   80/TCP,81/TCP,82/TCP   run=nginx2   11m
</code></pre>
</div>

<p>As mentioned previously, a Service is backed by a group of pods. These pods are exposed through <code>endpoints</code>. The Service’s selector will be evaluated continuously and the results will be POSTed to an Endpoints object also named <code>nginxsvc</code>. When a pod dies, it is automatically removed from the endpoints, and new pods matching the Service’s selector will automatically get added to the endpoints. Check the endpoints, and note that the IPs are the same as the pods created in the first step:</p>

<div class="highlight">
  <pre><code class="language-console">$ kubectl describe svc nginxsvc
Name:			nginxsvc
Namespace:		default
Labels:			app=nginx
Selector:		app=nginx
Type:			ClusterIP
IP:			10.0.116.146
Port:			&lt;unnamed&gt;	80/TCP
Endpoints:		10.245.0.14:80,10.245.0.15:80
Session Affinity:	None
No events.

$ kubectl get ep
NAME         ENDPOINTS
nginxsvc     10.245.0.14:80,10.245.0.15:80
</code></pre>
</div>

<p>You should now be able to curl the nginx Service on <code>10.0.116.146:80</code> from any node in your cluster. Note that the Service IP is completely virtual, it never hits the wire, if you’re curious about how this works you can read more about the <a href="services.html#virtual-ips-and-service-proxies">service proxy</a>.</p>

<h2 id="accessing-the-service">Accessing the Service</h2>

<p>Kubernetes supports 2 primary modes of finding a Service - environment variables and DNS. The former works out of the box while the latter requires the <a href="http://releases.k8s.io/release-1.1/cluster/addons/dns/README.md">kube-dns cluster addon</a>.</p>

<h3 id="environment-variables">Environment Variables</h3>

<p>When a Pod is run on a Node, the kubelet adds a set of environment variables for each active Service. This introduces an ordering problem. To see why, inspect the environment of your running nginx pods:</p>

<div class="highlight">
  <pre><code class="language-console">$ kubectl exec my-nginx-6isf4 -- printenv | grep SERVICE
KUBERNETES_SERVICE_HOST=10.0.0.1
KUBERNETES_SERVICE_PORT=443
</code></pre>
</div>

<p>Note there’s no mention of your Service. This is because you created the replicas before the Service. Another disadvantage of doing this is that the scheduler might put both pods on the same machine, which will take your entire Service down if it dies. We can do this the right way by killing the 2 pods and waiting for the replication controller to recreate them. This time around the Service exists <em>before</em> the replicas. This will given you scheduler level Service spreading of your pods (provided all your nodes have equal capacity), as well as the right environment variables:</p>

<div class="highlight">
  <pre><code class="language-console">$ kubectl scale rc my-nginx --replicas=0; kubectl scale rc my-nginx --replicas=2;
$ kubectl get pods -l app=nginx -o wide
NAME             READY   STATUS     RESTARTS   AGE   NODE
my-nginx-5j8ok   1/1     Running   	0         2m    node1
my-nginx-90vaf   1/1     Running   0          2m    node2

$ kubectl exec my-nginx-5j8ok -- printenv | grep SERVICE
KUBERNETES_SERVICE_PORT=443
NGINXSVC_SERVICE_HOST=10.0.116.146
KUBERNETES_SERVICE_HOST=10.0.0.1
NGINXSVC_SERVICE_PORT=80
</code></pre>
</div>

<h3 id="dns">DNS</h3>

<p>Kubernetes offers a DNS cluster addon Service that uses skydns to automatically assign dns names to other Services. You can check if it’s running on your cluster:</p>

<div class="highlight">
  <pre><code class="language-console">$ kubectl get services kube-dns --namespace=kube-system
NAME       CLUSTER_IP      EXTERNAL_IP   PORT(S)         SELECTOR           AGE
kube-dns   10.179.240.10   &lt;none&gt;        53/UDP,53/TCP   k8s-app=kube-dns   8d
</code></pre>
</div>

<p>If it isn’t running, you can <a href="http://releases.k8s.io/release-1.1/cluster/addons/dns/README.md#how-do-i-configure-it">enable it</a>. The rest of this section will assume you have a Service with a long lived IP (nginxsvc), and a dns server that has assigned a name to that IP (the kube-dns cluster addon), so you can talk to the Service from any pod in your cluster using standard methods (e.g. gethostbyname). Let’s create another pod to test this:</p>

<div class="highlight">
  <pre><code class="language-yaml">$ cat curlpod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: curlpod
spec:
  containers:
  - image: radial/busyboxplus:curl
    command:
      - sleep
      - "3600"
    imagePullPolicy: IfNotPresent
    name: curlcontainer
  restartPolicy: Always
</code></pre>
</div>

<p>And perform a lookup of the nginx Service</p>

<div class="highlight">
  <pre><code class="language-console">$ kubectl create -f ./curlpod.yaml
default/curlpod
$ kubectl get pods curlpod
NAME      READY     STATUS    RESTARTS   AGE
curlpod   1/1       Running   0          18s

$ kubectl exec curlpod -- nslookup nginxsvc
Server:    10.0.0.10
Address 1: 10.0.0.10
Name:      nginxsvc
Address 1: 10.0.116.146
</code></pre>
</div>

<h2 id="securing-the-service">Securing the Service</h2>

<p>Till now we have only accessed the nginx server from within the cluster. Before exposing the Service to the internet, you want to make sure the communication channel is secure. For this, you will need:
* Self signed certificates for https (unless you already have an identity certificate)
* An nginx server configured to use the certificates
* A <a href="secrets.html">secret</a> that makes the certificates accessible to pods</p>

<p>You can acquire all these from the <a href="../../examples/https-nginx/README.html">nginx https example</a>, in short:</p>

<div class="highlight">
  <pre><code class="language-console">$ make keys secret KEY=/tmp/nginx.key CERT=/tmp/nginx.crt SECRET=/tmp/secret.json
$ kubectl create -f /tmp/secret.json
secrets/nginxsecret
$ kubectl get secrets
NAME                  TYPE                                  DATA
default-token-il9rc   kubernetes.io/service-account-token   1
nginxsecret           Opaque                                2
</code></pre>
</div>

<p>Now modify your nginx replicas to start a https server using the certificate in the secret, and the Service, to expose both ports (80 and 443):</p>

<div class="highlight">
  <pre><code class="language-yaml">$ cat nginx-app.yaml
apiVersion: v1
kind: Service
metadata:
  name: nginxsvc
  labels:
    app: nginx
spec:
  type: NodePort
  ports:
  - port: 8080
    targetPort: 80
    protocol: TCP
    name: http
  - port: 443
    protocol: TCP
    name: https
  selector:
    app: nginx
---
apiVersion: v1
kind: ReplicationController
metadata:
  name: my-nginx
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: nginx
    spec:
      volumes:
      - name: secret-volume
        secret:
          secretName: nginxsecret
      containers:
      - name: nginxhttps
        image: bprashanth/nginxhttps:1.0
        ports:
        - containerPort: 443
        - containerPort: 80
        volumeMounts:
        - mountPath: /etc/nginx/ssl
          name: secret-volume
</code></pre>
</div>

<p>Noteworthy points about the nginx-app manifest:
- It contains both rc and service specification in the same file
- The <a href="../../examples/https-nginx/default.conf">nginx server</a> serves http traffic on port 80 and https traffic on 443, and nginx Service exposes both ports.
- Each container has access to the keys through a volume mounted at /etc/nginx/ssl. This is setup <em>before</em> the nginx server is started.</p>

<div class="highlight">
  <pre><code class="language-console">$ kubectl delete rc,svc -l app=nginx; kubectl create -f ./nginx-app.yaml
replicationcontrollers/my-nginx
services/nginxsvc
services/nginxsvc
replicationcontrollers/my-nginx
</code></pre>
</div>

<p>At this point you can reach the nginx server from any node.</p>

<div class="highlight">
  <pre><code class="language-console">$ kubectl get pods -o json | grep -i podip
    "podIP": "10.1.0.80",
node $ curl -k https://10.1.0.80
...
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
</code></pre>
</div>

<p>Note how we supplied the <code>-k</code> parameter to curl in the last step, this is because we don’t know anything about the pods running nginx at certificate generation time,
so we have to tell curl to ignore the CName mismatch. By creating a Service we linked the CName used in the certificate with the actual DNS name used by pods during Service lookup.
Lets test this from a pod (the same secret is being reused for simplicity, the pod only needs nginx.crt to access the Service):</p>

<div class="highlight">
  <pre><code class="language-console">$ cat curlpod.yaml
vapiVersion: v1
kind: ReplicationController
metadata:
  name: curlrc
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: curlpod
    spec:
      volumes:
      - name: secret-volume
        secret:
          secretName: nginxsecret
      containers:
      - name: curlpod
        command:
        - sh
        - -c
        - while true; do sleep 1; done
        image: radial/busyboxplus:curl
        volumeMounts:
        - mountPath: /etc/nginx/ssl
          name: secret-volume

$ kubectl create -f ./curlpod.yaml
$ kubectl get pods
NAME             READY     STATUS    RESTARTS   AGE
curlpod          1/1       Running   0          2m
my-nginx-7006w   1/1       Running   0          24m

$ kubectl exec curlpod -- curl https://nginxsvc --cacert /etc/nginx/ssl/nginx.crt
...
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
...
</code></pre>
</div>

<h2 id="exposing-the-service">Exposing the Service</h2>

<p>For some parts of your applications you may want to expose a Service onto an external IP address. Kubernetes supports two ways of doing this: NodePorts and LoadBalancers. The Service created in the last section already used <code>NodePort</code>, so your nginx https replica is ready to serve traffic on the internet if your node has a public IP.</p>

<div class="highlight">
  <pre><code class="language-console">$ kubectl get svc nginxsvc -o json | grep -i nodeport -C 5
            {
                "name": "http",
                "protocol": "TCP",
                "port": 80,
                "targetPort": 80,
                "nodePort": 32188
            },
            {
                "name": "https",
                "protocol": "TCP",
                "port": 443,
                "targetPort": 443,
                "nodePort": 30645
            }

$ kubectl get nodes -o json | grep ExternalIP -C 2
                    {
                        "type": "ExternalIP",
                        "address": "104.197.63.17"
                    }
--
                    },
                    {
                        "type": "ExternalIP",
                        "address": "104.154.89.170"
                    }
$ curl https://104.197.63.17:30645 -k
...
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
</code></pre>
</div>

<p>Lets now recreate the Service to use a cloud load balancer, just change the <code>Type</code> of Service in the nginx-app.yaml from <code>NodePort</code> to <code>LoadBalancer</code>:</p>

<div class="highlight">
  <pre><code class="language-console">$ kubectl delete rc, svc -l app=nginx
$ kubectl create -f ./nginx-app.yaml
$ kubectl get svc nginxsvc
NAME      CLUSTER_IP       EXTERNAL_IP       PORT(S)                SELECTOR     AGE
nginxsvc  10.179.252.126   162.222.184.144   80/TCP,81/TCP,82/TCP   run=nginx2   13m

$ curl https://162.22.184.144 -k
...
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
</code></pre>
</div>

<p>The IP address in the <code>EXTERNAL_IP</code> column is the one that is available on the public internet.  The <code>CLUSTER_IP</code> is only available inside your
cluster/private cloud network.</p>

<h2 id="whats-next">What’s next?</h2>

<p><a href="production-pods.html">Learn about more Kubernetes features that will help you run containers reliably in production.</a></p>

<!-- BEGIN MUNGE: IS_VERSIONED -->
<!-- TAG IS_VERSIONED -->
<!-- END MUNGE: IS_VERSIONED -->

<!-- BEGIN MUNGE: GENERATED_ANALYTICS -->
<p><a href=""><img src="https://kubernetes-site.appspot.com/UA-36037335-10/GitHub/docs/user-guide/connecting-applications.md?pixel" alt="Analytics" /></a>
<!-- END MUNGE: GENERATED_ANALYTICS --></p>


	</div>
</section>


<footer>
	<main class="light-text">
		<nav>
			<a href="/getting-started.html">Getting Started</a>
			<a href="/docs.html">Documentation</a>
			<a href="http://blog.kubernetes.io/">Blog</a>
			<a href="/foobang.html">Community</a>
		</nav>
		<div class="social">
			<a href="https://twitter.com/kubernetesio" class="twitter"><span>twitter</span></a>
			<a href="https://github.com/kubernetes/kubernetes" class="github"><span>Github</span></a>
			<a href="http://slack.k8s.io/" class="slack"><span>Slack</span></a>
			<a href="http://stackoverflow.com/questions/tagged/kubernetes" class="stack-overflow"><span>stackoverflow</span></a>
			<a href="https://groups.google.com/forum/#!forum/google-containers" class="mailing-list"><span>Mailing List</span></a>
			<label for="wishField">I wish this page <input type="text" id="wishField" name="wishField" placeholder="made better textfield suggestions"></label>
		</div>
		<div class="center">&copy; 2016 Kubernetes</div>
	</main>
</footer>

</body>
</html>



