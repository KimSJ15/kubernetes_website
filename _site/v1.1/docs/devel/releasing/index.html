<!Doctype html>
<html id="docs">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link href='https://fonts.googleapis.com/css?family=Roboto:400,100,100italic,300,300italic,400italic,500,500italic,700,700italic,900,900italic' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" href="/css/styles.css"/>
	<script src="/js/script.js"></script>
    <script src="/js/jquery-2.2.0.min.js"></script>
    <script src="/js/non-mini.js"></script>
    <title>Kubernetes - Releasing Kubernetes</title>
</head>
<body>
<div id="cellophane" onclick="kub.toggleMenu()"></div>
<header>
	<a href="/" class="logo"></a>
	<div class="nav-buttons" data-auto-burger="primary">
		<a href="/docs" class="button" id="viewDocs">View Documentation</a>
		<a href="/get-started" class="button" id="tryKubernetes">Try Kubernetes</a>
		<button id="hamburger" onclick="kub.toggleMenu()" data-auto-burger-exclude><div></div></button>
	</div>

	<nav id="mainNav">
		<main data-auto-burger="primary">
			<div class="nav-box">
				<h3><a href="">Get Started</a></h3>
				<p>Built for a multi-cloud world, public, private or hybrid. Seamlessly roll out new features.</p>
			</div>
			<div class="nav-box">
				<h3><a href="">Documentation</a></h3>
				<p>Pellentesque in ipsum id orci porta dapibus. Nulla porttitor accumsan tincidunt. </p>
			</div>
			<div class="nav-box">
				<h3><a href="">Community</a></h3>
				<p>Vestibulum ac diam sit amet quam vehicula elementum sed sit amet dui. </p>
			</div>
			<div class="nav-box">
				<h3><a href="">Blog</a></h3>
				<p>Curabitur arcu erat, accumsan id imperdiet et, porttitor at sem. Quisque velit nisi, pretium ut lacinia in. </p>
			</div>
		</main>
		<main data-auto-burger="primary">
			<div class="left">
				<h5 class="github-invite">Interested in hacking on the core Kubernetes code base?</h5>
				<a href="" class="button">View On Github</a>
			</div>

			<div class="right">
				<h5 class="github-invite">Explore the community</h5>
				<div class="social">
					<a href="https://twitter.com/kubernetesio" class="Twitter"><span>twitter</span></a>
					<a href="https://github.com/kubernetes/kubernetes" class="github"><span>Github</span></a>
					<a href="http://slack.k8s.io/" class="slack"><span>Slack</span></a>
					<a href="http://stackoverflow.com/questions/tagged/kubernetes" class="stack-overflow"><span>stackoverflow</span></a>
					<a href="https://groups.google.com/forum/#!forum/google-containers" class="mailing-list"><span>Mailing List</span></a>
				</div>
			</div>
			<div class="clear" style="clear: both"></div>
		</main>
	</nav>
</header>

<!--  HERO  -->
<section id="hero" class="light-text">
	<h1></h1>
	<h5></h5>
	<div id="vendorStrip" class="light-text">
		<ul>
			<li><a href="/v1.1/">GUIDES</a></li>
			<li><a href="/v1.1/reference">REFERENCE</a></li>
			<li><a href="/v1.1/samples">SAMPLES</a></li>
			<li><a href="/v1.1/support">SUPPORT</a></li>
		</ul>
		<div class="dropdown">
			<div class="readout"></div>
			<a href="/v1.1">Version 1.1</a>
			<a href="/v1.0">Version 1.0</a>
		</div>
		<input type="text" id="search" placeholder="Search the docs">
	</div>
</section>

<section id="encyclopedia">
	<div id="docsToc">
        <div class="pi-accordion">
            
            

        </div> <!-- /pi-accordion -->
	</div> <!-- /docsToc -->
	<div id="docsContent">
    	<h1>Releasing Kubernetes</h1>
		<!-- BEGIN MUNGE: UNVERSIONED_WARNING -->

<!-- END MUNGE: UNVERSIONED_WARNING -->

<h1 id="releasing-kubernetes">Releasing Kubernetes</h1>

<p>This document explains how to cut a release, and the theory behind it. If you
just want to cut a release and move on with your life, you can stop reading
after the first section.</p>

<h2 id="how-to-cut-a-kubernetes-release">How to cut a Kubernetes release</h2>

<p>Regardless of whether you are cutting a major or minor version, cutting a
release breaks down into four pieces:</p>

<ol>
  <li>Selecting release components.</li>
  <li>Tagging and merging the release in Git.</li>
  <li>Building and pushing the binaries.</li>
  <li>Writing release notes.</li>
</ol>

<p>You should progress in this strict order.</p>

<h3 id="building-a-new-majorminor-version-vxy0">Building a New Major/Minor Version (<code>vX.Y.0</code>)</h3>

<h4 id="selecting-release-components">Selecting Release Components</h4>

<p>When cutting a major/minor release, your first job is to find the branch
point. We cut <code>vX.Y.0</code> releases directly from <code>master</code>, which is also the
branch that we have most continuous validation on. Go first to <a href="http://go/k8s-test/job/kubernetes-e2e-gce">the main GCE
Jenkins end-to-end job</a> and next to <a href="http://go/k8s-test/view/Critical%20Builds">the
Critical Builds page</a> and hopefully find a
recent Git hash that looks stable across at least <code>kubernetes-e2e-gce</code> and
<code>kubernetes-e2e-gke-ci</code>. First glance through builds and look for nice solid
rows of green builds, and then check temporally with the other Critical Builds
to make sure they’re solid around then as well. Once you find some greens, you
can find the Git hash for a build by looking at the “Console Log”, then look for
<code>githash=</code>. You should see a line line:</p>

<div class="highlight">
  <pre><code class="language-console">+ githash=v0.20.2-322-g974377b
</code></pre>
</div>

<p>Because Jenkins builds frequently, if you’re looking between jobs
(e.g. <code>kubernetes-e2e-gke-ci</code> and <code>kubernetes-e2e-gce</code>), there may be no single
<code>githash</code> that’s been run on both jobs. In that case, take the a green
<code>kubernetes-e2e-gce</code> build (but please check that it corresponds to a temporally
similar build that’s green on <code>kubernetes-e2e-gke-ci</code>). Lastly, if you’re having
trouble understanding why the GKE continuous integration clusters are failing
and you’re trying to cut a release, don’t hesitate to contact the GKE
oncall.</p>

<p>Before proceeding to the next step:</p>

<div class="highlight">
  <pre><code class="language-sh">export BRANCHPOINT=v0.20.2-322-g974377b
</code></pre>
</div>

<p>Where <code>v0.20.2-322-g974377b</code> is the git hash you decided on. This will become
our (retroactive) branch point.</p>

<h4 id="branching-tagging-and-merging">Branching, Tagging and Merging</h4>

<p>Do the following:</p>

<ol>
  <li><code>export VER=x.y</code> (e.g. <code>0.20</code> for v0.20)</li>
  <li>cd to the base of the repo</li>
  <li><code>git fetch upstream &amp;&amp; git checkout -b release-${VER} ${BRANCHPOINT}</code> (you did set <code>${BRANCHPOINT}</code>, right?)</li>
  <li>Make sure you don’t have any files you care about littering your repo (they
better be checked in or outside the repo, or the next step will delete them).</li>
  <li><code>make clean &amp;&amp; git reset --hard HEAD &amp;&amp; git clean -xdf</code></li>
  <li><code>make</code> (TBD: you really shouldn’t have to do this, but the swagger output step requires it right now)</li>
  <li><code>./build/mark-new-version.sh v${VER}.0</code> to mark the new release and get further
instructions. This creates a series of commits on the branch you’re working
on (<code>release-${VER}</code>), including forking our documentation for the release,
the release version commit (which is then tagged), and the post-release
version commit.</li>
  <li>Follow the instructions given to you by that script. They are canon for the
remainder of the Git process. If you don’t understand something in that
process, please ask!</li>
</ol>

<p><strong>TODO</strong>: how to fix tags, etc., if you have to shift the release branchpoint.</p>

<h4 id="building-and-pushing-binaries">Building and Pushing Binaries</h4>

<p>In your git repo (you still have <code>${VER}</code> set from above right?):</p>

<ol>
  <li><code>git checkout upstream/master &amp;&amp; build/build-official-release.sh v${VER}.0</code> (the <code>build-official-release.sh</code> script is version agnostic, so it’s best to run it off <code>master</code> directly).</li>
  <li>Follow the instructions given to you by that script.</li>
  <li>At this point, you’ve done all the Git bits, you’ve got all the binary bits pushed, and you’ve got the template for the release started on GitHub.</li>
</ol>

<h4 id="writing-release-notes">Writing Release Notes</h4>

<p><a href="making-release-notes.html">This helpful guide</a> describes how to write release
notes for a major/minor release. In the release template on GitHub, leave the
last PR number that the tool finds for the <code>.0</code> release, so the next releaser
doesn’t have to hunt.</p>

<h3 id="building-a-new-patch-release-vxyz-for-z--0">Building a New Patch Release (<code>vX.Y.Z</code> for <code>Z &gt; 0</code>)</h3>

<h4 id="selecting-release-components-1">Selecting Release Components</h4>

<p>We cut <code>vX.Y.Z</code> releases from the <code>release-vX.Y</code> branch after all cherry picks
to the branch have been resolved. You should ensure all outstanding cherry picks
have been reviewed and merged and the branch validated on Jenkins (validation
TBD). See the <a href="cherry-picks.html">Cherry Picks</a> for more information on how to
manage cherry picks prior to cutting the release.</p>

<h4 id="tagging-and-merging">Tagging and Merging</h4>

<ol>
  <li><code>export VER=x.y</code> (e.g. <code>0.20</code> for v0.20)</li>
  <li><code>export PATCH=Z</code> where <code>Z</code> is the patch level of <code>vX.Y.Z</code></li>
  <li>cd to the base of the repo</li>
  <li><code>git fetch upstream &amp;&amp; git checkout -b upstream/release-${VER} release-${VER}</code></li>
  <li>Make sure you don’t have any files you care about littering your repo (they
better be checked in or outside the repo, or the next step will delete them).</li>
  <li><code>make clean &amp;&amp; git reset --hard HEAD &amp;&amp; git clean -xdf</code></li>
  <li><code>make</code> (TBD: you really shouldn’t have to do this, but the swagger output step requires it right now)</li>
  <li><code>./build/mark-new-version.sh v${VER}.${PATCH}</code> to mark the new release and get further
instructions. This creates a series of commits on the branch you’re working
on (<code>release-${VER}</code>), including forking our documentation for the release,
the release version commit (which is then tagged), and the post-release
version commit.</li>
  <li>Follow the instructions given to you by that script. They are canon for the
remainder of the Git process. If you don’t understand something in that
process, please ask! When proposing PRs, you can pre-fill the body with
<code>hack/cherry_pick_list.sh upstream/release-${VER}</code> to inform people of what
is already on the branch.</li>
</ol>

<p><strong>TODO</strong>: how to fix tags, etc., if the release is changed.</p>

<h4 id="building-and-pushing-binaries-1">Building and Pushing Binaries</h4>

<p>In your git repo (you still have <code>${VER}</code> and <code>${PATCH}</code> set from above right?):</p>

<ol>
  <li><code>git checkout upstream/master &amp;&amp; build/build-official-release.sh
v${VER}.${PATCH}</code> (the <code>build-official-release.sh</code> script is version
agnostic, so it’s best to run it off <code>master</code> directly).</li>
  <li>Follow the instructions given to you by that script. At this point, you’ve
done all the Git bits, you’ve got all the binary bits pushed, and you’ve got
the template for the release started on GitHub.</li>
</ol>

<h4 id="writing-release-notes-1">Writing Release Notes</h4>

<p>Run <code>hack/cherry_pick_list.sh ${VER}.${PATCH}~1</code> to get the release notes for
the patch release you just created. Feel free to prune anything internal, like
you would for a major release, but typically for patch releases we tend to
include everything in the release notes.</p>

<h2 id="origin-of-the-sources">Origin of the Sources</h2>

<p>Kubernetes may be built from either a git tree (using <code>hack/build-go.sh</code>) or
from a tarball (using either <code>hack/build-go.sh</code> or <code>go install</code>) or directly by
the Go native build system (using <code>go get</code>).</p>

<p>When building from git, we want to be able to insert specific information about
the build tree at build time. In particular, we want to use the output of <code>git
describe</code> to generate the version of Kubernetes and the status of the build
tree (add a <code>-dirty</code> prefix if the tree was modified.)</p>

<p>When building from a tarball or using the Go build system, we will not have
access to the information about the git tree, but we still want to be able to
tell whether this build corresponds to an exact release (e.g. v0.3) or is
between releases (e.g. at some point in development between v0.3 and v0.4).</p>

<h2 id="version-number-format">Version Number Format</h2>

<p>In order to account for these use cases, there are some specific formats that
may end up representing the Kubernetes version. Here are a few examples:</p>

<ul>
  <li><strong>v0.5</strong>: This is official version 0.5 and this version will only be used
when building from a clean git tree at the v0.5 git tag, or from a tree
extracted from the tarball corresponding to that specific release.</li>
  <li><strong>v0.5-15-g0123abcd4567</strong>: This is the <code>git describe</code> output and it indicates
that we are 15 commits past the v0.5 release and that the SHA1 of the commit
where the binaries were built was <code>0123abcd4567</code>. It is only possible to have
this level of detail in the version information when building from git, not
when building from a tarball.</li>
  <li><strong>v0.5-15-g0123abcd4567-dirty</strong> or <strong>v0.5-dirty</strong>: The extra <code>-dirty</code> prefix
means that the tree had local modifications or untracked files at the time of
the build, so there’s no guarantee that the source code matches exactly the
state of the tree at the <code>0123abcd4567</code> commit or at the <code>v0.5</code> git tag
(resp.)</li>
  <li><strong>v0.5-dev</strong>: This means we are building from a tarball or using <code>go get</code> or,
if we have a git tree, we are using <code>go install</code> directly, so it is not
possible to inject the git version into the build information. Additionally,
this is not an official release, so the <code>-dev</code> prefix indicates that the
version we are building is after <code>v0.5</code> but before <code>v0.6</code>. (There is actually
an exception where a commit with <code>v0.5-dev</code> is not present on <code>v0.6</code>, see
later for details.)</li>
</ul>

<h2 id="injecting-version-into-binaries">Injecting Version into Binaries</h2>

<p>In order to cover the different build cases, we start by providing information
that can be used when using only Go build tools or when we do not have the git
version information available.</p>

<p>To be able to provide a meaningful version in those cases, we set the contents
of variables in a Go source file that will be used when no overrides are
present.</p>

<p>We are using <code>pkg/version/base.go</code> as the source of versioning in absence of
information from git. Here is a sample of that file’s contents:</p>

<div class="highlight">
  <pre><code class="language-go">var (
    gitVersion   string = "v0.4-dev"  // version from git, output of $(git describe)
    gitCommit    string = ""          // sha1 from git, output of $(git rev-parse HEAD)
)
</code></pre>
</div>

<p>This means a build with <code>go install</code> or <code>go get</code> or a build from a tarball will
yield binaries that will identify themselves as <code>v0.4-dev</code> and will not be able
to provide you with a SHA1.</p>

<p>To add the extra versioning information when building from git, the
<code>hack/build-go.sh</code> script will gather that information (using <code>git describe</code> and
<code>git rev-parse</code>) and then create a <code>-ldflags</code> string to pass to <code>go install</code> and
tell the Go linker to override the contents of those variables at build time. It
can, for instance, tell it to override <code>gitVersion</code> and set it to
<code>v0.4-13-g4567bcdef6789-dirty</code> and set <code>gitCommit</code> to <code>4567bcdef6789...</code> which
is the complete SHA1 of the (dirty) tree used at build time.</p>

<h2 id="handling-official-versions">Handling Official Versions</h2>

<p>Handling official versions from git is easy, as long as there is an annotated
git tag pointing to a specific version then <code>git describe</code> will return that tag
exactly which will match the idea of an official version (e.g. <code>v0.5</code>).</p>

<p>Handling it on tarballs is a bit harder since the exact version string must be
present in <code>pkg/version/base.go</code> for it to get embedded into the binaries. But
simply creating a commit with <code>v0.5</code> on its own would mean that the commits
coming after it would also get the <code>v0.5</code> version when built from tarball or <code>go
get</code> while in fact they do not match <code>v0.5</code> (the one that was tagged) exactly.</p>

<p>To handle that case, creating a new release should involve creating two adjacent
commits where the first of them will set the version to <code>v0.5</code> and the second
will set it to <code>v0.5-dev</code>. In that case, even in the presence of merges, there
will be a single commit where the exact <code>v0.5</code> version will be used and all
others around it will either have <code>v0.4-dev</code> or <code>v0.5-dev</code>.</p>

<p>The diagram below illustrates it.</p>

<p><img src="releasing.png" alt="Diagram of git commits involved in the release" /></p>

<p>After working on <code>v0.4-dev</code> and merging PR 99 we decide it is time to release
<code>v0.5</code>. So we start a new branch, create one commit to update
<code>pkg/version/base.go</code> to include <code>gitVersion = "v0.5"</code> and <code>git commit</code> it.</p>

<p>We test it and make sure everything is working as expected.</p>

<p>Before sending a PR for it, we create a second commit on that same branch,
updating <code>pkg/version/base.go</code> to include <code>gitVersion = "v0.5-dev"</code>. That will
ensure that further builds (from tarball or <code>go install</code>) on that tree will
always include the <code>-dev</code> prefix and will not have a <code>v0.5</code> version (since they
do not match the official <code>v0.5</code> exactly.)</p>

<p>We then send PR 100 with both commits in it.</p>

<p>Once the PR is accepted, we can use <code>git tag -a</code> to create an annotated tag
<em>pointing to the one commit</em> that has <code>v0.5</code> in <code>pkg/version/base.go</code> and push
it to GitHub. (Unfortunately GitHub tags/releases are not annotated tags, so
this needs to be done from a git client and pushed to GitHub using SSH or
HTTPS.)</p>

<h2 id="parallel-commits">Parallel Commits</h2>

<p>While we are working on releasing <code>v0.5</code>, other development takes place and
other PRs get merged. For instance, in the example above, PRs 101 and 102 get
merged to the master branch before the versioning PR gets merged.</p>

<p>This is not a problem, it is only slightly inaccurate that checking out the tree
at commit <code>012abc</code> or commit <code>345cde</code> or at the commit of the merges of PR 101
or 102 will yield a version of <code>v0.4-dev</code> <em>but</em> those commits are not present in
<code>v0.5</code>.</p>

<p>In that sense, there is a small window in which commits will get a
<code>v0.4-dev</code> or <code>v0.4-N-gXXX</code> label and while they’re indeed later than <code>v0.4</code>
but they are not really before <code>v0.5</code> in that <code>v0.5</code> does not contain those
commits.</p>

<p>Unfortunately, there is not much we can do about it. On the other hand, other
projects seem to live with that and it does not really become a large problem.</p>

<p>As an example, Docker commit a327d9b91edf has a <code>v1.1.1-N-gXXX</code> label but it is
not present in Docker <code>v1.2.0</code>:</p>

<div class="highlight">
  <pre><code class="language-console">$ git describe a327d9b91edf
v1.1.1-822-ga327d9b91edf

$ git log --oneline v1.2.0..a327d9b91edf
a327d9b91edf Fix data space reporting from Kb/Mb to KB/MB

(Non-empty output here means the commit is not present on v1.2.0.)
</code></pre>
</div>

<h2 id="release-notes">Release Notes</h2>

<p>No official release should be made final without properly matching release notes.</p>

<p>There should be made available, per release, a small summary, preamble, of the
major changes, both in terms of feature improvements/bug fixes and notes about
functional feature changes (if any) regarding the previous released version so
that the BOM regarding updating to it gets as obvious and trouble free as possible.</p>

<p>After this summary, preamble, all the relevant PRs/issues that got in that
version should be listed and linked together with a small summary understandable
by plain mortals (in a perfect world PR/issue’s title would be enough but often
it is just too cryptic/geeky/domain-specific that it isn’t).</p>

<!-- BEGIN MUNGE: IS_VERSIONED -->
<!-- TAG IS_VERSIONED -->
<!-- END MUNGE: IS_VERSIONED -->

<!-- BEGIN MUNGE: GENERATED_ANALYTICS -->
<p><a href=""><img src="https://kubernetes-site.appspot.com/UA-36037335-10/GitHub/docs/devel/releasing.md?pixel" alt="Analytics" /></a>
<!-- END MUNGE: GENERATED_ANALYTICS --></p>


	</div>
</section>


<footer>
	<main class="light-text">
		<nav>
			<a href="/getting-started.html">Getting Started</a>
			<a href="/docs.html">Documentation</a>
			<a href="http://blog.kubernetes.io/">Blog</a>
			<a href="/foobang.html">Community</a>
		</nav>
		<div class="social">
			<a href="https://twitter.com/kubernetesio" class="twitter"><span>twitter</span></a>
			<a href="https://github.com/kubernetes/kubernetes" class="github"><span>Github</span></a>
			<a href="http://slack.k8s.io/" class="slack"><span>Slack</span></a>
			<a href="http://stackoverflow.com/questions/tagged/kubernetes" class="stack-overflow"><span>stackoverflow</span></a>
			<a href="https://groups.google.com/forum/#!forum/google-containers" class="mailing-list"><span>Mailing List</span></a>
			<label for="wishField">I wish this page <input type="text" id="wishField" name="wishField" placeholder="made better textfield suggestions"></label>
		</div>
		<div class="center">&copy; 2016 Kubernetes</div>
	</main>
</footer>

</body>
</html>



