<!Doctype html>
<html id="docs">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link href='https://fonts.googleapis.com/css?family=Roboto:400,100,100italic,300,300italic,400italic,500,500italic,700,700italic,900,900italic' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" href="/css/styles.css"/>
	<script src="/js/script.js"></script>
    <script src="/js/jquery-2.2.0.min.js"></script>
    <script src="/js/non-mini.js"></script>
    <title>Kubernetes - Container Command Execution & Port Forwarding in Kubernetes</title>
</head>
<body>
<div id="cellophane" onclick="kub.toggleMenu()"></div>
<header>
	<a href="/" class="logo"></a>
	<div class="nav-buttons" data-auto-burger="primary">
		<a href="/docs" class="button" id="viewDocs">View Documentation</a>
		<a href="/get-started" class="button" id="tryKubernetes">Try Kubernetes</a>
		<button id="hamburger" onclick="kub.toggleMenu()" data-auto-burger-exclude><div></div></button>
	</div>

	<nav id="mainNav">
		<main data-auto-burger="primary">
			<div class="nav-box">
				<h3><a href="">Get Started</a></h3>
				<p>Built for a multi-cloud world, public, private or hybrid. Seamlessly roll out new features.</p>
			</div>
			<div class="nav-box">
				<h3><a href="">Documentation</a></h3>
				<p>Pellentesque in ipsum id orci porta dapibus. Nulla porttitor accumsan tincidunt. </p>
			</div>
			<div class="nav-box">
				<h3><a href="">Community</a></h3>
				<p>Vestibulum ac diam sit amet quam vehicula elementum sed sit amet dui. </p>
			</div>
			<div class="nav-box">
				<h3><a href="">Blog</a></h3>
				<p>Curabitur arcu erat, accumsan id imperdiet et, porttitor at sem. Quisque velit nisi, pretium ut lacinia in. </p>
			</div>
		</main>
		<main data-auto-burger="primary">
			<div class="left">
				<h5 class="github-invite">Interested in hacking on the core Kubernetes code base?</h5>
				<a href="" class="button">View On Github</a>
			</div>

			<div class="right">
				<h5 class="github-invite">Explore the community</h5>
				<div class="social">
					<a href="https://twitter.com/kubernetesio" class="Twitter"><span>twitter</span></a>
					<a href="https://github.com/kubernetes/kubernetes" class="github"><span>Github</span></a>
					<a href="http://slack.k8s.io/" class="slack"><span>Slack</span></a>
					<a href="http://stackoverflow.com/questions/tagged/kubernetes" class="stack-overflow"><span>stackoverflow</span></a>
					<a href="https://groups.google.com/forum/#!forum/google-containers" class="mailing-list"><span>Mailing List</span></a>
				</div>
			</div>
			<div class="clear" style="clear: both"></div>
		</main>
	</nav>
</header>

<!--  HERO  -->
<section id="hero" class="light-text">
	<h1></h1>
	<h5></h5>
	<div id="vendorStrip" class="light-text">
		<ul>
			<li><a href="/v1.1/">GUIDES</a></li>
			<li><a href="/v1.1/reference">REFERENCE</a></li>
			<li><a href="/v1.1/samples">SAMPLES</a></li>
			<li><a href="/v1.1/support">SUPPORT</a></li>
		</ul>
		<div class="dropdown">
			<div class="readout"></div>
			<a href="/v1.1">Version 1.1</a>
			<a href="/v1.0">Version 1.0</a>
		</div>
		<input type="text" id="search" placeholder="Search the docs">
	</div>
</section>

<section id="encyclopedia">
	<div id="docsToc">
        <div class="pi-accordion">
            
            

        </div> <!-- /pi-accordion -->
	</div> <!-- /docsToc -->
	<div id="docsContent">
    	<h1>Container Command Execution & Port Forwarding in Kubernetes</h1>
		<!-- BEGIN MUNGE: UNVERSIONED_WARNING -->

<!-- END MUNGE: UNVERSIONED_WARNING -->

<h1 id="container-command-execution--port-forwarding-in-kubernetes">Container Command Execution &amp; Port Forwarding in Kubernetes</h1>

<h2 id="abstract">Abstract</h2>

<p>This describes an approach for providing support for:</p>

<ul>
  <li>executing commands in containers, with stdin/stdout/stderr streams attached</li>
  <li>port forwarding to containers</li>
</ul>

<h2 id="background">Background</h2>

<p>There are several related issues/PRs:</p>

<ul>
  <li><a href="http://issue.k8s.io/1521">Support attach</a></li>
  <li><a href="http://issue.k8s.io/1513">Real container ssh</a></li>
  <li><a href="http://issue.k8s.io/1863">Provide easy debug network access to services</a></li>
  <li><a href="https://github.com/openshift/origin/pull/576">OpenShift container command execution proposal</a></li>
</ul>

<h2 id="motivation">Motivation</h2>

<p>Users and administrators are accustomed to being able to access their systems
via SSH to run remote commands, get shell access, and do port forwarding.</p>

<p>Supporting SSH to containers in Kubernetes is a difficult task. You must
specify a “user” and a hostname to make an SSH connection, and <code>sshd</code> requires
real users (resolvable by NSS and PAM). Because a container belongs to a pod,
and the pod belongs to a namespace, you need to specify namespace/pod/container
to uniquely identify the target container. Unfortunately, a
namespace/pod/container is not a real user as far as SSH is concerned. Also,
most Linux systems limit user names to 32 characters, which is unlikely to be
large enough to contain namespace/pod/container. We could devise some scheme to
map each namespace/pod/container to a 32-character user name, adding entries to
<code>/etc/passwd</code> (or LDAP, etc.) and keeping those entries fully in sync all the
time. Alternatively, we could write custom NSS and PAM modules that allow the
host to resolve a namespace/pod/container to a user without needing to keep
files or LDAP in sync.</p>

<p>As an alternative to SSH, we are using a multiplexed streaming protocol that
runs on top of HTTP. There are no requirements about users being real users,
nor is there any limitation on user name length, as the protocol is under our
control. The only downside is that standard tooling that expects to use SSH
won’t be able to work with this mechanism, unless adapters can be written.</p>

<h2 id="constraints-and-assumptions">Constraints and Assumptions</h2>

<ul>
  <li>SSH support is not currently in scope</li>
  <li>CGroup confinement is ultimately desired, but implementing that support is not currently in scope</li>
  <li>SELinux confinement is ultimately desired, but implementing that support is not currently in scope</li>
</ul>

<h2 id="use-cases">Use Cases</h2>

<ul>
  <li>As a user of a Kubernetes cluster, I want to run arbitrary commands in a container, attaching my local stdin/stdout/stderr to the container</li>
  <li>As a user of a Kubernetes cluster, I want to be able to connect to local ports on my computer and have them forwarded to ports in the container</li>
</ul>

<h2 id="process-flow">Process Flow</h2>

<h3 id="remote-command-execution-flow">Remote Command Execution Flow</h3>

<ol>
  <li>The client connects to the Kubernetes Master to initiate a remote command execution
request</li>
  <li>The Master proxies the request to the Kubelet where the container lives</li>
  <li>The Kubelet executes nsenter + the requested command and streams stdin/stdout/stderr back and forth between the client and the container</li>
</ol>

<h3 id="port-forwarding-flow">Port Forwarding Flow</h3>

<ol>
  <li>The client connects to the Kubernetes Master to initiate a remote command execution
request</li>
  <li>The Master proxies the request to the Kubelet where the container lives</li>
  <li>The client listens on each specified local port, awaiting local connections</li>
  <li>The client connects to one of the local listening ports</li>
  <li>The client notifies the Kubelet of the new connection</li>
  <li>The Kubelet executes nsenter + socat and streams data back and forth between the client and the port in the container</li>
</ol>

<h2 id="design-considerations">Design Considerations</h2>

<h3 id="streaming-protocol">Streaming Protocol</h3>

<p>The current multiplexed streaming protocol used is SPDY. This is not the
long-term desire, however. As soon as there is viable support for HTTP/2 in Go,
we will switch to that.</p>

<h3 id="master-as-first-level-proxy">Master as First Level Proxy</h3>

<p>Clients should not be allowed to communicate directly with the Kubelet for
security reasons. Therefore, the Master is currently the only suggested entry
point to be used for remote command execution and port forwarding. This is not
necessarily desirable, as it means that all remote command execution and port
forwarding traffic must travel through the Master, potentially impacting other
API requests.</p>

<p>In the future, it might make more sense to retrieve an authorization token from
the Master, and then use that token to initiate a remote command execution or
port forwarding request with a load balanced proxy service dedicated to this
functionality. This would keep the streaming traffic out of the Master.</p>

<h3 id="kubelet-as-backend-proxy">Kubelet as Backend Proxy</h3>

<p>The kubelet is currently responsible for handling remote command execution and
port forwarding requests. Just like with the Master described above, this means
that all remote command execution and port forwarding streaming traffic must
travel through the Kubelet, which could result in a degraded ability to service
other requests.</p>

<p>In the future, it might make more sense to use a separate service on the node.</p>

<p>Alternatively, we could possibly inject a process into the container that only
listens for a single request, expose that process’s listening port on the node,
and then issue a redirect to the client such that it would connect to the first
level proxy, which would then proxy directly to the injected process’s exposed
port. This would minimize the amount of proxying that takes place.</p>

<h3 id="scalability">Scalability</h3>

<p>There are at least 2 different ways to execute a command in a container:
<code>docker exec</code> and <code>nsenter</code>. While <code>docker exec</code> might seem like an easier and
more obvious choice, it has some drawbacks.</p>

<h4 id="docker-exec"><code>docker exec</code></h4>

<p>We could expose <code>docker exec</code> (i.e. have Docker listen on an exposed TCP port
on the node), but this would require proxying from the edge and securing the
Docker API. <code>docker exec</code> calls go through the Docker daemon, meaning that all
stdin/stdout/stderr traffic is proxied through the Daemon, adding an extra hop.
Additionally, you can’t isolate 1 malicious <code>docker exec</code> call from normal
usage, meaning an attacker could initiate a denial of service or other attack
and take down the Docker daemon, or the node itself.</p>

<p>We expect remote command execution and port forwarding requests to be long
running and/or high bandwidth operations, and routing all the streaming data
through the Docker daemon feels like a bottleneck we can avoid.</p>

<h4 id="nsenter"><code>nsenter</code></h4>

<p>The implementation currently uses <code>nsenter</code> to run commands in containers,
joining the appropriate container namespaces. <code>nsenter</code> runs directly on the
node and is not proxied through any single daemon process.</p>

<h3 id="security">Security</h3>

<p>Authentication and authorization hasn’t specifically been tested yet with this
functionality. We need to make sure that users are not allowed to execute
remote commands or do port forwarding to containers they aren’t allowed to
access.</p>

<p>Additional work is required to ensure that multiple command execution or port forwarding connections from different clients are not able to see each other’s data. This can most likely be achieved via SELinux labeling and unique process contexts.</p>

<!-- BEGIN MUNGE: IS_VERSIONED -->
<!-- TAG IS_VERSIONED -->
<!-- END MUNGE: IS_VERSIONED -->

<!-- BEGIN MUNGE: GENERATED_ANALYTICS -->
<p><a href=""><img src="https://kubernetes-site.appspot.com/UA-36037335-10/GitHub/docs/design/command_execution_port_forwarding.md?pixel" alt="Analytics" /></a>
<!-- END MUNGE: GENERATED_ANALYTICS --></p>


	</div>
</section>


<footer>
	<main class="light-text">
		<nav>
			<a href="/getting-started.html">Getting Started</a>
			<a href="/docs.html">Documentation</a>
			<a href="http://blog.kubernetes.io/">Blog</a>
			<a href="/foobang.html">Community</a>
		</nav>
		<div class="social">
			<a href="https://twitter.com/kubernetesio" class="twitter"><span>twitter</span></a>
			<a href="https://github.com/kubernetes/kubernetes" class="github"><span>Github</span></a>
			<a href="http://slack.k8s.io/" class="slack"><span>Slack</span></a>
			<a href="http://stackoverflow.com/questions/tagged/kubernetes" class="stack-overflow"><span>stackoverflow</span></a>
			<a href="https://groups.google.com/forum/#!forum/google-containers" class="mailing-list"><span>Mailing List</span></a>
			<label for="wishField">I wish this page <input type="text" id="wishField" name="wishField" placeholder="made better textfield suggestions"></label>
		</div>
		<div class="center">&copy; 2016 Kubernetes</div>
	</main>
</footer>

</body>
</html>



