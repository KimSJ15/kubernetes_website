<!Doctype html>
<html id="docs">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link href='https://fonts.googleapis.com/css?family=Roboto:400,100,100italic,300,300italic,400italic,500,500italic,700,700italic,900,900italic' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" href="/css/styles.css"/>
	<script src="/js/script.js"></script>
    <script src="/js/jquery-2.2.0.min.js"></script>
    <script src="/js/non-mini.js"></script>
    <title>Kubernetes - Namespaces</title>
</head>
<body>
<div id="cellophane" onclick="kub.toggleMenu()"></div>
<header>
	<a href="/" class="logo"></a>
	<div class="nav-buttons" data-auto-burger="primary">
		<a href="/docs" class="button" id="viewDocs">View Documentation</a>
		<a href="/get-started" class="button" id="tryKubernetes">Try Kubernetes</a>
		<button id="hamburger" onclick="kub.toggleMenu()" data-auto-burger-exclude><div></div></button>
	</div>

	<nav id="mainNav">
		<main data-auto-burger="primary">
			<div class="nav-box">
				<h3><a href="">Get Started</a></h3>
				<p>Built for a multi-cloud world, public, private or hybrid. Seamlessly roll out new features.</p>
			</div>
			<div class="nav-box">
				<h3><a href="">Documentation</a></h3>
				<p>Pellentesque in ipsum id orci porta dapibus. Nulla porttitor accumsan tincidunt. </p>
			</div>
			<div class="nav-box">
				<h3><a href="">Community</a></h3>
				<p>Vestibulum ac diam sit amet quam vehicula elementum sed sit amet dui. </p>
			</div>
			<div class="nav-box">
				<h3><a href="">Blog</a></h3>
				<p>Curabitur arcu erat, accumsan id imperdiet et, porttitor at sem. Quisque velit nisi, pretium ut lacinia in. </p>
			</div>
		</main>
		<main data-auto-burger="primary">
			<div class="left">
				<h5 class="github-invite">Interested in hacking on the core Kubernetes code base?</h5>
				<a href="" class="button">View On Github</a>
			</div>

			<div class="right">
				<h5 class="github-invite">Explore the community</h5>
				<div class="social">
					<a href="https://twitter.com/kubernetesio" class="Twitter"><span>twitter</span></a>
					<a href="https://github.com/kubernetes/kubernetes" class="github"><span>Github</span></a>
					<a href="http://slack.k8s.io/" class="slack"><span>Slack</span></a>
					<a href="http://stackoverflow.com/questions/tagged/kubernetes" class="stack-overflow"><span>stackoverflow</span></a>
					<a href="https://groups.google.com/forum/#!forum/google-containers" class="mailing-list"><span>Mailing List</span></a>
				</div>
			</div>
			<div class="clear" style="clear: both"></div>
		</main>
	</nav>
</header>

<!--  HERO  -->
<section id="hero" class="light-text">
	<h1></h1>
	<h5></h5>
	<div id="vendorStrip" class="light-text">
		<ul>
			<li><a href="/v1.1/">GUIDES</a></li>
			<li><a href="/v1.1/reference">REFERENCE</a></li>
			<li><a href="/v1.1/samples">SAMPLES</a></li>
			<li><a href="/v1.1/support">SUPPORT</a></li>
		</ul>
		<div class="dropdown">
			<div class="readout"></div>
			<a href="/v1.1">Version 1.1</a>
			<a href="/v1.0">Version 1.0</a>
		</div>
		<input type="text" id="search" placeholder="Search the docs">
	</div>
</section>

<section id="encyclopedia">
	<div id="docsToc">
        <div class="pi-accordion">
            
            

        </div> <!-- /pi-accordion -->
	</div> <!-- /docsToc -->
	<div id="docsContent">
    	<h1>Namespaces</h1>
		<!-- BEGIN MUNGE: UNVERSIONED_WARNING -->

<!-- END MUNGE: UNVERSIONED_WARNING -->

<h1 id="namespaces">Namespaces</h1>

<h2 id="abstract">Abstract</h2>

<p>A Namespace is a mechanism to partition resources created by users into
a logically named group.</p>

<h2 id="motivation">Motivation</h2>

<p>A single cluster should be able to satisfy the needs of multiple user communities.</p>

<p>Each user community wants to be able to work in isolation from other communities.</p>

<p>Each user community has its own:</p>

<ol>
  <li>resources (pods, services, replication controllers, etc.)</li>
  <li>policies (who can or cannot perform actions in their community)</li>
  <li>constraints (this community is allowed this much quota, etc.)</li>
</ol>

<p>A cluster operator may create a Namespace for each unique user community.</p>

<p>The Namespace provides a unique scope for:</p>

<ol>
  <li>named resources (to avoid basic naming collisions)</li>
  <li>delegated management authority to trusted users</li>
  <li>ability to limit community resource consumption</li>
</ol>

<h2 id="use-cases">Use cases</h2>

<ol>
  <li>As a cluster operator, I want to support multiple user communities on a single cluster.</li>
  <li>As a cluster operator, I want to delegate authority to partitions of the cluster to trusted users
in those communities.</li>
  <li>As a cluster operator, I want to limit the amount of resources each community can consume in order
to limit the impact to other communities using the cluster.</li>
  <li>As a cluster user, I want to interact with resources that are pertinent to my user community in
isolation of what other user communities are doing on the cluster.</li>
</ol>

<h2 id="design">Design</h2>

<h3 id="data-model">Data Model</h3>

<p>A <em>Namespace</em> defines a logically named group for multiple <em>Kind</em>s of resources.</p>

<div class="highlight">
  <pre><code class="language-go">type Namespace struct {
  TypeMeta   `json:",inline"`
  ObjectMeta `json:"metadata,omitempty"`

  Spec NamespaceSpec `json:"spec,omitempty"`
  Status NamespaceStatus `json:"status,omitempty"`
}
</code></pre>
</div>

<p>A <em>Namespace</em> name is a DNS compatible label.</p>

<p>A <em>Namespace</em> must exist prior to associating content with it.</p>

<p>A <em>Namespace</em> must not be deleted if there is content associated with it.</p>

<p>To associate a resource with a <em>Namespace</em> the following conditions must be satisfied:</p>

<ol>
  <li>The resource’s <em>Kind</em> must be registered as having <em>RESTScopeNamespace</em> with the server</li>
  <li>The resource’s <em>TypeMeta.Namespace</em> field must have a value that references an existing <em>Namespace</em></li>
</ol>

<p>The <em>Name</em> of a resource associated with a <em>Namespace</em> is unique to that <em>Kind</em> in that <em>Namespace</em>.</p>

<p>It is intended to be used in resource URLs; provided by clients at creation time, and encouraged to be
human friendly; intended to facilitate idempotent creation, space-uniqueness of singleton objects,
distinguish distinct entities, and reference particular entities across operations.</p>

<h3 id="authorization">Authorization</h3>

<p>A <em>Namespace</em> provides an authorization scope for accessing content associated with the <em>Namespace</em>.</p>

<p>See <a href="../admin/authorization.html">Authorization plugins</a></p>

<h3 id="limit-resource-consumption">Limit Resource Consumption</h3>

<p>A <em>Namespace</em> provides a scope to limit resource consumption.</p>

<p>A <em>LimitRange</em> defines min/max constraints on the amount of resources a single entity can consume in
a <em>Namespace</em>.</p>

<p>See <a href="admission_control_limit_range.html">Admission control: Limit Range</a></p>

<p>A <em>ResourceQuota</em> tracks aggregate usage of resources in the <em>Namespace</em> and allows cluster operators
to define <em>Hard</em> resource usage limits that a <em>Namespace</em> may consume.</p>

<p>See <a href="admission_control_resource_quota.html">Admission control: Resource Quota</a></p>

<h3 id="finalizers">Finalizers</h3>

<p>Upon creation of a <em>Namespace</em>, the creator may provide a list of <em>Finalizer</em> objects.</p>

<div class="highlight">
  <pre><code class="language-go">type FinalizerName string

// These are internal finalizers to Kubernetes, must be qualified name unless defined here
const (
  FinalizerKubernetes FinalizerName = "kubernetes"
)

// NamespaceSpec describes the attributes on a Namespace
type NamespaceSpec struct {
  // Finalizers is an opaque list of values that must be empty to permanently remove object from storage
  Finalizers []FinalizerName
}
</code></pre>
</div>

<p>A <em>FinalizerName</em> is a qualified name.</p>

<p>The API Server enforces that a <em>Namespace</em> can only be deleted from storage if and only if
it’s <em>Namespace.Spec.Finalizers</em> is empty.</p>

<p>A <em>finalize</em> operation is the only mechanism to modify the <em>Namespace.Spec.Finalizers</em> field post creation.</p>

<p>Each <em>Namespace</em> created has <em>kubernetes</em> as an item in its list of initial <em>Namespace.Spec.Finalizers</em>
set by default.</p>

<h3 id="phases">Phases</h3>

<p>A <em>Namespace</em> may exist in the following phases.</p>

<div class="highlight">
  <pre><code class="language-go">type NamespacePhase string
const(
  NamespaceActive NamespacePhase = "Active"
  NamespaceTerminating NamespaceTerminating = "Terminating"
)

type NamespaceStatus struct { 
  ...
  Phase NamespacePhase 
}
</code></pre>
</div>

<p>A <em>Namespace</em> is in the <strong>Active</strong> phase if it does not have a <em>ObjectMeta.DeletionTimestamp</em>.</p>

<p>A <em>Namespace</em> is in the <strong>Terminating</strong> phase if it has a <em>ObjectMeta.DeletionTimestamp</em>.</p>

<p><strong>Active</strong></p>

<p>Upon creation, a <em>Namespace</em> goes in the <em>Active</em> phase.  This means that content may be associated with
a namespace, and all normal interactions with the namespace are allowed to occur in the cluster.</p>

<p>If a DELETE request occurs for a <em>Namespace</em>, the <em>Namespace.ObjectMeta.DeletionTimestamp</em> is set
to the current server time.  A <em>namespace controller</em> observes the change, and sets the <em>Namespace.Status.Phase</em>
to <em>Terminating</em>.</p>

<p><strong>Terminating</strong></p>

<p>A <em>namespace controller</em> watches for <em>Namespace</em> objects that have a <em>Namespace.ObjectMeta.DeletionTimestamp</em>
value set in order to know when to initiate graceful termination of the <em>Namespace</em> associated content that
are known to the cluster.</p>

<p>The <em>namespace controller</em> enumerates each known resource type in that namespace and deletes it one by one.</p>

<p>Admission control blocks creation of new resources in that namespace in order to prevent a race-condition
where the controller could believe all of a given resource type had been deleted from the namespace,
when in fact some other rogue client agent had created new objects.  Using admission control in this
scenario allows each of registry implementations for the individual objects to not need to take into account Namespace life-cycle.</p>

<p>Once all objects known to the <em>namespace controller</em> have been deleted, the <em>namespace controller</em>
executes a <em>finalize</em> operation on the namespace that removes the <em>kubernetes</em> value from
the <em>Namespace.Spec.Finalizers</em> list.</p>

<p>If the <em>namespace controller</em> sees a <em>Namespace</em> whose <em>ObjectMeta.DeletionTimestamp</em> is set, and
whose <em>Namespace.Spec.Finalizers</em> list is empty, it will signal the server to permanently remove
the <em>Namespace</em> from storage by sending a final DELETE action to the API server.</p>

<h3 id="rest-api">REST API</h3>

<p>To interact with the Namespace API:</p>

<table>
  <thead>
    <tr>
      <th>Action</th>
      <th>HTTP Verb</th>
      <th>Path</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CREATE</td>
      <td>POST</td>
      <td>/api/{version}/namespaces</td>
      <td>Create a namespace</td>
    </tr>
    <tr>
      <td>LIST</td>
      <td>GET</td>
      <td>/api/{version}/namespaces</td>
      <td>List all namespaces</td>
    </tr>
    <tr>
      <td>UPDATE</td>
      <td>PUT</td>
      <td>/api/{version}/namespaces/{namespace}</td>
      <td>Update namespace {namespace}</td>
    </tr>
    <tr>
      <td>DELETE</td>
      <td>DELETE</td>
      <td>/api/{version}/namespaces/{namespace}</td>
      <td>Delete namespace {namespace}</td>
    </tr>
    <tr>
      <td>FINALIZE</td>
      <td>POST</td>
      <td>/api/{version}/namespaces/{namespace}/finalize</td>
      <td>Finalize namespace {namespace}</td>
    </tr>
    <tr>
      <td>WATCH</td>
      <td>GET</td>
      <td>/api/{version}/watch/namespaces</td>
      <td>Watch all namespaces</td>
    </tr>
  </tbody>
</table>

<p>This specification reserves the name <em>finalize</em> as a sub-resource to namespace.</p>

<p>As a consequence, it is invalid to have a <em>resourceType</em> managed by a namespace whose kind is <em>finalize</em>.</p>

<p>To interact with content associated with a Namespace:</p>

<table>
  <thead>
    <tr>
      <th>Action</th>
      <th>HTTP Verb</th>
      <th>Path</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CREATE</td>
      <td>POST</td>
      <td>/api/{version}/namespaces/{namespace}/{resourceType}/</td>
      <td>Create instance of {resourceType} in namespace {namespace}</td>
    </tr>
    <tr>
      <td>GET</td>
      <td>GET</td>
      <td>/api/{version}/namespaces/{namespace}/{resourceType}/{name}</td>
      <td>Get instance of {resourceType} in namespace {namespace} with {name}</td>
    </tr>
    <tr>
      <td>UPDATE</td>
      <td>PUT</td>
      <td>/api/{version}/namespaces/{namespace}/{resourceType}/{name}</td>
      <td>Update instance of {resourceType} in namespace {namespace} with {name}</td>
    </tr>
    <tr>
      <td>DELETE</td>
      <td>DELETE</td>
      <td>/api/{version}/namespaces/{namespace}/{resourceType}/{name}</td>
      <td>Delete instance of {resourceType} in namespace {namespace} with {name}</td>
    </tr>
    <tr>
      <td>LIST</td>
      <td>GET</td>
      <td>/api/{version}/namespaces/{namespace}/{resourceType}</td>
      <td>List instances of {resourceType} in namespace {namespace}</td>
    </tr>
    <tr>
      <td>WATCH</td>
      <td>GET</td>
      <td>/api/{version}/watch/namespaces/{namespace}/{resourceType}</td>
      <td>Watch for changes to a {resourceType} in namespace {namespace}</td>
    </tr>
    <tr>
      <td>WATCH</td>
      <td>GET</td>
      <td>/api/{version}/watch/{resourceType}</td>
      <td>Watch for changes to a {resourceType} across all namespaces</td>
    </tr>
    <tr>
      <td>LIST</td>
      <td>GET</td>
      <td>/api/{version}/list/{resourceType}</td>
      <td>List instances of {resourceType} across all namespaces</td>
    </tr>
  </tbody>
</table>

<p>The API server verifies the <em>Namespace</em> on resource creation matches the <em>{namespace}</em> on the path.</p>

<p>The API server will associate a resource with a <em>Namespace</em> if not populated by the end-user based on the <em>Namespace</em> context
of the incoming request.  If the <em>Namespace</em> of the resource being created, or updated does not match the <em>Namespace</em> on the request,
then the API server will reject the request.</p>

<h3 id="storage">Storage</h3>

<p>A namespace provides a unique identifier space and therefore must be in the storage path of a resource.</p>

<p>In etcd, we want to continue to still support efficient WATCH across namespaces.</p>

<p>Resources that persist content in etcd will have storage paths as follows:</p>

<p>/{k8s_storage_prefix}/{resourceType}/{resource.Namespace}/{resource.Name}</p>

<p>This enables consumers to WATCH /registry/{resourceType} for changes across namespace of a particular {resourceType}.</p>

<h3 id="kubelet">Kubelet</h3>

<p>The kubelet will register pod’s it sources from a file or http source with a namespace associated with the
<em>cluster-id</em></p>

<h3 id="example-openshift-origin-managing-a-kubernetes-namespace">Example: OpenShift Origin managing a Kubernetes Namespace</h3>

<p>In this example, we demonstrate how the design allows for agents built on-top of
Kubernetes that manage their own set of resource types associated with a <em>Namespace</em>
to take part in Namespace termination.</p>

<p>OpenShift creates a Namespace in Kubernetes</p>

<div class="highlight">
  <pre><code class="language-json">{
  "apiVersion":"v1",
  "kind": "Namespace",
  "metadata": {
    "name": "development",
    "labels": {
      "name": "development"
    }
  },
  "spec": {
    "finalizers": ["openshift.com/origin", "kubernetes"]
  },
  "status": {
    "phase": "Active"
  }
}
</code></pre>
</div>

<p>OpenShift then goes and creates a set of resources (pods, services, etc) associated
with the “development” namespace.  It also creates its own set of resources in its
own storage associated with the “development” namespace unknown to Kubernetes.</p>

<p>User deletes the Namespace in Kubernetes, and Namespace now has following state:</p>

<div class="highlight">
  <pre><code class="language-json">{
  "apiVersion":"v1",
  "kind": "Namespace",
  "metadata": {
    "name": "development",
    "deletionTimestamp": "..."
    "labels": {
      "name": "development"
    }
  },
  "spec": {
    "finalizers": ["openshift.com/origin", "kubernetes"]
  },
  "status": {
    "phase": "Terminating"
  }
}
</code></pre>
</div>

<p>The Kubernetes <em>namespace controller</em> observes the namespace has a <em>deletionTimestamp</em>
and begins to terminate all of the content in the namespace that it knows about.  Upon
success, it executes a <em>finalize</em> action that modifies the <em>Namespace</em> by
removing <em>kubernetes</em> from the list of finalizers:</p>

<div class="highlight">
  <pre><code class="language-json">{
  "apiVersion":"v1",
  "kind": "Namespace",
  "metadata": {
    "name": "development",
    "deletionTimestamp": "..."
    "labels": {
      "name": "development"
    }
  },
  "spec": {
    "finalizers": ["openshift.com/origin"]
  },
  "status": {
    "phase": "Terminating"
  }
}
</code></pre>
</div>

<p>OpenShift Origin has its own <em>namespace controller</em> that is observing cluster state, and
it observes the same namespace had a <em>deletionTimestamp</em> assigned to it.  It too will go
and purge resources from its own storage that it manages associated with that namespace.
Upon completion, it executes a <em>finalize</em> action and removes the reference to “openshift.com/origin”
from the list of finalizers.</p>

<p>This results in the following state:</p>

<div class="highlight">
  <pre><code class="language-json">{
  "apiVersion":"v1",
  "kind": "Namespace",
  "metadata": {
    "name": "development",
    "deletionTimestamp": "..."
    "labels": {
      "name": "development"
    }
  },
  "spec": {
    "finalizers": []
  },
  "status": {
    "phase": "Terminating"
  }
}
</code></pre>
</div>

<p>At this point, the Kubernetes <em>namespace controller</em> in its sync loop will see that the namespace
has a deletion timestamp and that its list of finalizers is empty.  As a result, it knows all
content associated from that namespace has been purged.  It performs a final DELETE action
to remove that Namespace from the storage.</p>

<p>At this point, all content associated with that Namespace, and the Namespace itself are gone.</p>

<!-- BEGIN MUNGE: IS_VERSIONED -->
<!-- TAG IS_VERSIONED -->
<!-- END MUNGE: IS_VERSIONED -->

<!-- BEGIN MUNGE: GENERATED_ANALYTICS -->
<p><a href=""><img src="https://kubernetes-site.appspot.com/UA-36037335-10/GitHub/docs/design/namespaces.md?pixel" alt="Analytics" /></a>
<!-- END MUNGE: GENERATED_ANALYTICS --></p>


	</div>
</section>


<footer>
	<main class="light-text">
		<nav>
			<a href="/getting-started.html">Getting Started</a>
			<a href="/docs.html">Documentation</a>
			<a href="http://blog.kubernetes.io/">Blog</a>
			<a href="/foobang.html">Community</a>
		</nav>
		<div class="social">
			<a href="https://twitter.com/kubernetesio" class="twitter"><span>twitter</span></a>
			<a href="https://github.com/kubernetes/kubernetes" class="github"><span>Github</span></a>
			<a href="http://slack.k8s.io/" class="slack"><span>Slack</span></a>
			<a href="http://stackoverflow.com/questions/tagged/kubernetes" class="stack-overflow"><span>stackoverflow</span></a>
			<a href="https://groups.google.com/forum/#!forum/google-containers" class="mailing-list"><span>Mailing List</span></a>
			<label for="wishField">I wish this page <input type="text" id="wishField" name="wishField" placeholder="made better textfield suggestions"></label>
		</div>
		<div class="center">&copy; 2016 Kubernetes</div>
	</main>
</footer>

</body>
</html>



